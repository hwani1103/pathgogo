using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class TestUIManager : MonoBehaviour
{
    [Header("UI References")]
    [SerializeField] private Button nextLevelButton;
    [SerializeField] private Button restartButton;
    [SerializeField] private TextMeshProUGUI statusText;
    [SerializeField] private TextMeshProUGUI pathInfoText;

    [Header("Game State Display")]
    [SerializeField] private GameObject gameOverPanel;
    [SerializeField] private GameObject gameClearPanel;
    [SerializeField] private GameObject allLevelsCompletePanel;
    [SerializeField] private TextMeshProUGUI gameOverText;

    private MovementGameManager gameManager;
    private PathSelectionManager pathSelectionManager;
    private LevelLoader levelLoader;

    void Awake()
    {
        gameManager = FindFirstObjectByType<MovementGameManager>();
        pathSelectionManager = FindFirstObjectByType<PathSelectionManager>();
        levelLoader = FindFirstObjectByType<LevelLoader>();

        SetupUI();
    }

    void Start()
    {
        UpdateUI();
    }

    void Update()
    {
        UpdateUI();
    }

    private void SetupUI()
    {
        if (nextLevelButton != null)
        {
            nextLevelButton.onClick.RemoveAllListeners();
            nextLevelButton.onClick.AddListener(OnNextLevelClicked);
            nextLevelButton.gameObject.SetActive(false);

            var buttonText = nextLevelButton.GetComponentInChildren<TextMeshProUGUI>();
            if (buttonText != null)
            {
                buttonText.text = "Next Level";
            }
        }

        if (restartButton != null)
        {
            restartButton.onClick.RemoveAllListeners();
            restartButton.onClick.AddListener(OnRestartClicked);
            restartButton.gameObject.SetActive(false);
        }

        HideAllPanels();
    }

    private void UpdateUI()
    {
        UpdateStatusText();
        UpdatePathInfoText();
    }

    private void UpdateStatusText()
    {
        if (statusText == null || gameManager == null) return;

        string status = "Status: ";

        if (gameManager.IsGameInProgress())
        {
            status += "Game In Progress";
        }
        else if (gameManager.AreAllPathsComplete())
        {
            status += "Ready to Start";
        }
        else
        {
            status += "Setting Paths...";
        }

        statusText.text = status;
    }

    private void UpdatePathInfoText()
    {
        if (pathInfoText == null || levelLoader == null) return;

        var characters = levelLoader.GetSpawnedCharacters();
        int completedCount = 0;

        foreach (var character in characters)
        {
            if (character.IsCompleted())
                completedCount++;
        }

        pathInfoText.text = $"Completed Paths: {completedCount}/{characters.Count}";
    }

    private void OnNextLevelClicked()
    {
        if (levelLoader != null)
        {
            levelLoader.LoadNextLevel();
        }

        HideAllPanels();
    }

    private void OnRestartClicked()
    {
        if (levelLoader != null)
        {
            levelLoader.RestartCurrentLevel();
        }

        HideAllPanels();
    }

    public void ShowGameOverUI(string message)
    {
        if (gameOverPanel != null)
        {
            gameOverPanel.SetActive(true);
        }

        if (gameOverText != null)
        {
            gameOverText.text = $"Game Over!\n{message}";
        }

        if (restartButton != null)
        {
            restartButton.gameObject.SetActive(true);
        }
    }

    public void ShowLevelClearedUI()
    {
        if (gameClearPanel != null)
        {
            gameClearPanel.SetActive(true);
        }

        if (nextLevelButton != null)
        {
            nextLevelButton.gameObject.SetActive(true);
        }
    }

    public void ShowAllLevelsCompleted()
    {
        if (allLevelsCompletePanel != null)
        {
            allLevelsCompletePanel.SetActive(true);
        }
    }

    private void HideAllPanels()
    {
        if (gameOverPanel != null)
            gameOverPanel.SetActive(false);
        if (gameClearPanel != null)
            gameClearPanel.SetActive(false);
        if (allLevelsCompletePanel != null)
            allLevelsCompletePanel.SetActive(false);

        if (nextLevelButton != null)
            nextLevelButton.gameObject.SetActive(false);
        if (restartButton != null)
            restartButton.gameObject.SetActive(false);
    }
}using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 캐릭터 이동과 충돌을 통합 관리하는 게임 매니저
/// Unity 물리 충돌 시스템만 사용
/// </summary>
public class MovementGameManager : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private PathSelectionManager pathSelectionManager;
    [SerializeField] private LevelLoader levelLoader;
    [SerializeField] private TestUIManager testUIManager;

    [Header("Game State")]
    [SerializeField] private bool gameInProgress = false;
    [SerializeField] private bool movementStarted = false;

    // 캐릭터 이동 관리
    private Dictionary<string, CharacterMover> characterMovers;
    private Dictionary<string, CharacterCollisionDetector> collisionDetectors;

    private GridVisualizer gridVisualizer;

    void Awake()
    {
        if (pathSelectionManager == null)
            pathSelectionManager = FindFirstObjectByType<PathSelectionManager>();
        if (levelLoader == null)
            levelLoader = FindFirstObjectByType<LevelLoader>();
        if (testUIManager == null)
            testUIManager = FindFirstObjectByType<TestUIManager>();

        gridVisualizer = FindFirstObjectByType<GridVisualizer>();

        characterMovers = new Dictionary<string, CharacterMover>();
        collisionDetectors = new Dictionary<string, CharacterCollisionDetector>();
    }

    void Start()
    {
        InitializeCharacterMovers();
        SetupCollisionDetection();
    }

    public bool IsGameInProgress()
    {
        return gameInProgress;
    }

    public void OnPathCompleted()
    {
        bool allComplete = AreAllPathsComplete();

        if (allComplete && !gameInProgress)
        {
            StartGame();
        }
    }

    /// <summary>
    /// 모든 캐릭터에 CharacterMover 및 물리 컴포넌트 추가
    /// </summary>
    private void InitializeCharacterMovers()
    {
        if (levelLoader == null) return;

        var characters = levelLoader.GetSpawnedCharacters();

        foreach (var character in characters)
        {
            // CharacterMover 추가
            var mover = character.GetComponent<CharacterMover>();
            if (mover == null)
            {
                mover = character.gameObject.AddComponent<CharacterMover>();
            }
            characterMovers[character.GetCharacterId()] = mover;

            // 물리 충돌용 Collider 추가
            var collider = character.GetComponent<CircleCollider2D>();
            if (collider == null)
            {
                collider = character.gameObject.AddComponent<CircleCollider2D>();
                collider.radius = 0.35f; // 타일 크기의 70% 정도
                collider.isTrigger = true;
            }

            // Rigidbody2D 추가
            var rigidbody = character.GetComponent<Rigidbody2D>();
            if (rigidbody == null)
            {
                rigidbody = character.gameObject.AddComponent<Rigidbody2D>();
                rigidbody.gravityScale = 0;
                rigidbody.freezeRotation = true;
            }
        }
    }

    /// <summary>
    /// 물리 기반 충돌 감지 시스템 설정
    /// </summary>
    private void SetupCollisionDetection()
    {
        var characters = levelLoader.GetSpawnedCharacters();

        foreach (var character in characters)
        {
            var detector = character.GetComponent<CharacterCollisionDetector>();
            if (detector == null)
            {
                detector = character.gameObject.AddComponent<CharacterCollisionDetector>();
            }

            detector.Initialize(this, character.GetCharacterId());
            collisionDetectors[character.GetCharacterId()] = detector;
        }
    }

    /// <summary>
    /// 충돌 감지 활성화/비활성화
    /// </summary>
    private void SetCollisionDetectionEnabled(bool enabled)
    {
        foreach (var detector in collisionDetectors.Values)
        {
            detector.SetCollisionEnabled(enabled);
        }
    }

    public bool AreAllPathsComplete()
    {
        if (levelLoader == null) return false;

        var characters = levelLoader.GetSpawnedCharacters();
        foreach (var character in characters)
        {
            if (!character.IsCompleted())
            {
                return false;
            }
        }

        return characters.Count > 0;
    }

    public void StartGame()
    {
        if (gameInProgress)
        {
            return;
        }

        if (!AreAllPathsComplete())
        {
            return;
        }

        gameInProgress = true;
        StartCoroutine(GameSequence());
    }

    /// <summary>
    /// 게임 진행 시퀀스
    /// </summary>
    private IEnumerator GameSequence()
    {
        var characterPaths = CollectAllCharacterPaths();
        if (characterPaths.Count == 0)
        {
            yield break;
        }

        // 충돌 감지 활성화
        SetCollisionDetectionEnabled(true);

        yield return new WaitForSeconds(1f);

        // 모든 캐릭터 이동 시작
        StartAllCharacterMovement(characterPaths);

        // 모든 캐릭터 이동 완료까지 대기
        yield return StartCoroutine(WaitForAllMovementComplete());

        // 게임 종료 처리
        OnGameComplete();
    }

    private Dictionary<string, List<Vector3Int>> CollectAllCharacterPaths()
    {
        if (pathSelectionManager == null)
        {
            return new Dictionary<string, List<Vector3Int>>();
        }

        return pathSelectionManager.GetCompletedPaths();
    }

    private void StartAllCharacterMovement(Dictionary<string, List<Vector3Int>> characterPaths)
    {
        movementStarted = true;

        foreach (var kvp in characterPaths)
        {
            string characterId = kvp.Key;
            List<Vector3Int> path = kvp.Value;

            if (characterMovers.ContainsKey(characterId))
            {
                characterMovers[characterId].StartMovement(path);
            }
            else
            {
                var characters = levelLoader.GetSpawnedCharacters();
                var character = characters.Find(c => c.GetCharacterId() == characterId);
                if (character != null)
                {
                    var mover = character.gameObject.AddComponent<CharacterMover>();
                    characterMovers[characterId] = mover;
                    mover.StartMovement(path);
                }
            }
        }
    }

    /// <summary>
    /// 물리 충돌 이벤트 처리 (CharacterCollisionDetector에서 호출)
    /// </summary>
    public void OnCharacterCollision(string characterId1, string characterId2, Vector3 collisionPoint)
    {
        if (!gameInProgress || !movementStarted)
        {
            return;
        }

        // 이동 중인 캐릭터들만 충돌로 간주
        bool char1Moving = characterMovers.ContainsKey(characterId1) && characterMovers[characterId1].IsMoving();
        bool char2Moving = characterMovers.ContainsKey(characterId2) && characterMovers[characterId2].IsMoving();

        if (!char1Moving || !char2Moving)
        {
            return;
        }

        // Goal 위치에서의 충돌은 무시
        Vector3Int gridPos = gridVisualizer.WorldToGridPosition(collisionPoint);
        if (IsGoalPosition(gridPos))
        {
            return;
        }

        // 즉시 게임 중단
        StopGameImmediately();

        // 충돌 이벤트 생성
        var collision = new CollisionPredictor.CollisionEvent(
            Time.time,
            gridPos,
            new List<string> { characterId1, characterId2 }
        );

        ShowGameOverUI(collision);
    }

    /// <summary>
    /// 즉시 게임 중단
    /// </summary>
    private void StopGameImmediately()
    {
        // 모든 캐릭터 이동 중단
        foreach (var mover in characterMovers.Values)
        {
            mover.StopAllCoroutines();

            var rb = mover.GetComponent<Rigidbody2D>();
            if (rb != null)
            {
                rb.linearVelocity = Vector2.zero;
                rb.angularVelocity = 0f;
            }
        }

        // 충돌 감지 비활성화
        SetCollisionDetectionEnabled(false);

        // 게임 상태 변경
        gameInProgress = false;
        movementStarted = false;
    }

    private bool IsGoalPosition(Vector3Int position)
    {
        if (levelLoader == null) return false;

        var goals = levelLoader.GetSpawnedGoals();
        foreach (var goal in goals)
        {
            if (goal.GetGridPosition() == position)
            {
                return true;
            }
        }
        return false;
    }

    private IEnumerator WaitForAllMovementComplete()
    {
        while (movementStarted)
        {
            bool allComplete = true;

            foreach (var mover in characterMovers.Values)
            {
                if (mover.IsMoving())
                {
                    allComplete = false;
                    break;
                }
            }

            if (allComplete)
            {
                movementStarted = false;
                break;
            }

            yield return new WaitForSeconds(0.1f);
        }
    }

    private void OnGameComplete()
    {
        SetCollisionDetectionEnabled(false);
        gameInProgress = false;

        // LevelLoader에 레벨 클리어 알림
        var levelLoader = FindFirstObjectByType<LevelLoader>();
        if (levelLoader != null)
        {
            levelLoader.OnLevelCleared();
        }
        else
        {
            ShowGameClearUI(); // 기존 메서드 유지
        }
    }
    /// <summary>
    /// 레벨 변경 시 호출 - 모든 참조 정리
    /// </summary>
    public void OnLevelChanged()
    {
        // 진행 중인 게임 강제 중단
        StopAllCoroutines();

        // 게임 상태 리셋
        gameInProgress = false;
        movementStarted = false;

        // CharacterMover 참조 정리
        if (characterMovers != null)
        {
            characterMovers.Clear();
        }

        if (collisionDetectors != null)
        {
            collisionDetectors.Clear();
        }

        Debug.Log("MovementGameManager cleaned up for level change");
    }

    /// <summary>
    /// 캐릭터 무버 초기화 - 새 레벨 시작 전에 호출
    /// </summary>
    public void InitializeForNewLevel()
    {
        // 새로운 캐릭터들에 대해 CharacterMover 설정
        InitializeCharacterMovers();
        SetupCollisionDetection();

        Debug.Log("MovementGameManager initialized for new level");
    }
    private void ShowGameOverUI(CollisionPredictor.CollisionEvent collision)
    {
        string message = $"Characters {string.Join(", ", collision.characterIds)} collided at {collision.position}";

        // LevelLoader에 게임 오버 알림
        var levelLoader = FindFirstObjectByType<LevelLoader>();
        if (levelLoader != null)
        {
            levelLoader.OnGameOver(message);
        }
        else if (testUIManager != null)
        {
            testUIManager.ShowGameOverUI(message);
        }
    }

    private void ShowGameClearUI()
    {
        if (testUIManager != null)
        {
            testUIManager.ShowLevelClearedUI(); // 메서드명 변경
        }
    }

    public void RestartGame()
    {
        foreach (var mover in characterMovers.Values)
        {
            mover.StopAllCoroutines();
        }

        SetCollisionDetectionEnabled(false);
        gameInProgress = false;
        movementStarted = false;

        ResetCharacterPositions();
    }

    private void ResetCharacterPositions()
    {
        if (levelLoader == null) return;

        var characters = levelLoader.GetSpawnedCharacters();
        foreach (var character in characters)
        {
            string characterId = character.GetCharacterId();
            Vector3Int startPos = GetCharacterStartPosition(character);

            if (characterMovers.ContainsKey(characterId))
            {
                characterMovers[characterId].TeleportToPosition(startPos);
            }

            character.SetCompleted(false);
        }

        if (pathSelectionManager != null)
        {
            pathSelectionManager.ClearAllCompletedPaths();
        }
    }

    private Vector3Int GetCharacterStartPosition(GamePiece character)
    {
        if (levelLoader != null)
        {
            var levelData = levelLoader.GetCurrentLevelData();
            if (levelData != null)
            {
                string characterId = character.GetCharacterId();
                foreach (var charData in levelData.characters)
                {
                    if (charData.characterId == characterId)
                    {
                        return charData.startPosition;
                    }
                }
            }
        }

        return character.GetCurrentGridPosition();
    }
}

/// <summary>
/// 각 캐릭터에 부착되어 물리 충돌을 감지하는 컴포넌트
/// </summary>
public class CharacterCollisionDetector : MonoBehaviour
{
    private MovementGameManager gameManager;
    private string characterId;
    private bool collisionEnabled = false;
    private HashSet<string> collidedWith = new HashSet<string>();

    public void Initialize(MovementGameManager manager, string id)
    {
        gameManager = manager;
        characterId = id;
    }

    public void SetCollisionEnabled(bool enabled)
    {
        collisionEnabled = enabled;
        if (!enabled)
        {
            collidedWith.Clear();
        }
    }

    void OnTriggerEnter2D(Collider2D other)
    {
        if (!collisionEnabled) return;

        var otherCharacter = other.GetComponent<GamePiece>();
        if (otherCharacter != null && gameManager != null)
        {
            string otherCharacterId = otherCharacter.GetCharacterId();

            if (otherCharacterId == characterId) return;

            if (collidedWith.Contains(otherCharacterId)) return;
            collidedWith.Add(otherCharacterId);

            Vector3 collisionPoint = (transform.position + other.transform.position) * 0.5f;
            gameManager.OnCharacterCollision(characterId, otherCharacterId, collisionPoint);
        }
    }
}using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CharacterMover : MonoBehaviour
{
    [Header("Movement Settings")]
    [SerializeField] private float moveSpeed = 2f;
    [SerializeField] private AnimationCurve movementCurve = AnimationCurve.Linear(0, 0, 1, 1);

    private bool isMoving = false;
    private List<Vector3Int> currentPath;
    private Coroutine movementCoroutine;

    private GridVisualizer gridVisualizer;
    private GamePiece gamePiece;

    void Awake()
    {
        gridVisualizer = FindFirstObjectByType<GridVisualizer>();
        gamePiece = GetComponent<GamePiece>();
    }

    public void StartMovement(List<Vector3Int> path)
    {
        if (isMoving)
        {
            StopMovement();
        }

        currentPath = new List<Vector3Int>(path);
        movementCoroutine = StartCoroutine(MoveAlongPath());
    }

    public void StopMovement()
    {
        if (movementCoroutine != null)
        {
            StopCoroutine(movementCoroutine);
            movementCoroutine = null;
        }
        isMoving = false;
    }

    private IEnumerator MoveAlongPath()
    {
        if (currentPath == null || currentPath.Count < 2)
        {
            Debug.LogWarning($"Invalid path for character {gamePiece.GetCharacterId()}");
            yield break;
        }

        isMoving = true;

        for (int i = 0; i < currentPath.Count - 1; i++)
        {
            Vector3Int fromPos = currentPath[i];
            Vector3Int toPos = currentPath[i + 1];

            yield return StartCoroutine(MoveToPosition(fromPos, toPos));
        }

        isMoving = false;
        OnMovementComplete();
    }

    private IEnumerator MoveToPosition(Vector3Int fromGrid, Vector3Int toGrid)
    {
        Vector3 fromWorld = gridVisualizer.GridToWorldPosition(fromGrid);
        Vector3 toWorld = gridVisualizer.GridToWorldPosition(toGrid);

        float distance = Vector3.Distance(fromWorld, toWorld);
        float duration = distance / moveSpeed;
        float elapsedTime = 0f;

        while (elapsedTime < duration)
        {
            elapsedTime += Time.deltaTime;
            float progress = elapsedTime / duration;

            float curveProgress = movementCurve.Evaluate(progress);

            Vector3 currentPosition = Vector3.Lerp(fromWorld, toWorld, curveProgress);
            transform.position = currentPosition;

            yield return null;
        }

        transform.position = toWorld;
    }

    public Vector3Int GetPositionAtTime(float targetTime)
    {
        if (currentPath == null || currentPath.Count == 0)
            return gamePiece.GetCurrentGridPosition();

        float currentTime = 0f;

        for (int i = 0; i < currentPath.Count - 1; i++)
        {
            Vector3Int fromPos = currentPath[i];
            Vector3Int toPos = currentPath[i + 1];

            float distance = Vector3Int.Distance(fromPos, toPos);
            float segmentDuration = distance / moveSpeed;

            if (targetTime <= currentTime + segmentDuration)
            {
                float segmentProgress = (targetTime - currentTime) / segmentDuration;

                if (segmentProgress < 1f)
                {
                    return fromPos;
                }
                else
                {
                    return toPos;
                }
            }

            currentTime += segmentDuration;
        }

        return currentPath[currentPath.Count - 1];
    }

    public bool IsMoving()
    {
        return isMoving;
    }

    public List<Vector3Int> GetCurrentPath()
    {
        return currentPath != null ? new List<Vector3Int>(currentPath) : new List<Vector3Int>();
    }

    public void SetMoveSpeed(float speed)
    {
        moveSpeed = speed;
    }

    private void OnMovementComplete()
    {
        Debug.Log($"Character {gamePiece.GetCharacterId()} completed movement");

        Vector3Int finalPosition = currentPath[currentPath.Count - 1];
    }

    public void TeleportToPosition(Vector3Int gridPosition)
    {
        StopMovement();
        Vector3 worldPosition = gridVisualizer.GridToWorldPosition(gridPosition);
        transform.position = worldPosition;
    }

    public void DebugDrawPath()
    {
        if (currentPath == null || currentPath.Count < 2) return;

        for (int i = 0; i < currentPath.Count - 1; i++)
        {
            Vector3 from = gridVisualizer.GridToWorldPosition(currentPath[i]);
            Vector3 to = gridVisualizer.GridToWorldPosition(currentPath[i + 1]);

            Debug.DrawLine(from, to, Color.cyan, 2f);
        }
    }
}using System.Collections.Generic;
using System.Linq;
using UnityEngine;

/// <summary>
/// 캐릭터 이동 전 충돌을 사전 계산하는 시스템
/// </summary>
public class CollisionPredictor : MonoBehaviour
{
    [System.Serializable]
    public struct CollisionEvent
    {
        public float time;              // 충돌 발생 시간
        public Vector3Int position;     // 충돌 발생 위치
        public List<string> characterIds; // 충돌하는 캐릭터들

        public CollisionEvent(float t, Vector3Int pos, List<string> ids)
        {
            time = t;
            position = pos;
            characterIds = new List<string>(ids);
        }
    }

    [Header("Movement Settings")]
    [SerializeField] private float moveSpeed = 2f;

    // 참조
    private GridVisualizer gridVisualizer;

    void Awake()
    {
        gridVisualizer = FindFirstObjectByType<GridVisualizer>();
    }

    /// <summary>
    /// 모든 캐릭터의 경로를 분석하여 충돌 이벤트들을 계산
    /// </summary>
    public List<CollisionEvent> PredictCollisions(Dictionary<string, List<Vector3Int>> characterPaths)
    {
        Debug.Log($"PredictCollisions called with {characterPaths.Count} characters");

        var collisionEvents = new List<CollisionEvent>();
        var characterTimelines = new Dictionary<string, List<TimePosition>>();

        // 1단계: 각 캐릭터의 시간별 위치 계산
        foreach (var kvp in characterPaths)
        {
            string characterId = kvp.Key;
            List<Vector3Int> path = kvp.Value;

            Debug.Log($"Processing path for {characterId}: {string.Join(" -> ", path)}");

            var timeline = CalculateTimeline(path);
            characterTimelines[characterId] = timeline;
        }

        // 2단계: 모든 시간 지점에서 충돌 검사
        var allTimePoints = GetAllTimePoints(characterTimelines);
        Debug.Log($"Total time points to check: {allTimePoints.Count}");

        foreach (float time in allTimePoints)
        {
            var positionsAtTime = GetPositionsAtTime(characterTimelines, time);
            Debug.Log($"At time {time:F2}: {string.Join(", ", positionsAtTime.Select(kvp => $"{kvp.Key}={kvp.Value}"))}");

            var collision = CheckCollisionAtTime(positionsAtTime, time);

            if (collision.HasValue)
            {
                collisionEvents.Add(collision.Value);
            }
        }

        return collisionEvents;
    }

    /// <summary>
    /// 경로를 시간별 위치 정보로 변환
    /// </summary>
    private List<TimePosition> CalculateTimeline(List<Vector3Int> path)
    {
        Debug.Log($"CalculateTimeline called with path: {string.Join(" -> ", path)}");

        var timeline = new List<TimePosition>();

        if (path.Count == 0)
        {
            Debug.LogWarning("Empty path provided");
            return timeline;
        }

        float currentTime = 0f;
        Vector3Int currentPos = path[0];

        timeline.Add(new TimePosition(currentTime, currentPos));
        Debug.Log($"Added timeline point: Time={currentTime}, Pos={currentPos}");

        for (int i = 1; i < path.Count; i++)
        {
            Vector3Int nextPos = path[i];
            float distance = Vector3Int.Distance(currentPos, nextPos);
            float segmentTime = distance / moveSpeed;

            currentTime += segmentTime;
            timeline.Add(new TimePosition(currentTime, nextPos));

            Debug.Log($"Added timeline point: Time={currentTime:F2}, Pos={nextPos}, Distance={distance}, SegmentTime={segmentTime:F2}");

            currentPos = nextPos;
        }

        Debug.Log($"Timeline complete: {timeline.Count} points, total time: {currentTime:F2}s");
        return timeline;
    }

    /// <summary>
    /// 특정 시간에 특정 위치에 있는 캐릭터 찾기
    /// </summary>
    private Vector3Int GetPositionAtTime(List<TimePosition> timeline, float targetTime)
    {
        Debug.Log($"GetPositionAtTime called: targetTime={targetTime:F2}");

        if (timeline.Count == 0) return Vector3Int.zero;
        if (targetTime <= timeline[0].time)
        {
            Debug.Log($"Before first point, returning {timeline[0].position}");
            return timeline[0].position;
        }

        for (int i = 1; i < timeline.Count; i++)
        {
            if (targetTime <= timeline[i].time)
            {
                var prevPoint = timeline[i - 1];
                var nextPoint = timeline[i];

                float segmentProgress = (targetTime - prevPoint.time) / (nextPoint.time - prevPoint.time);

                Debug.Log($"Between points: {prevPoint.position} (t={prevPoint.time:F2}) -> {nextPoint.position} (t={nextPoint.time:F2})");
                Debug.Log($"Segment progress: {segmentProgress:F2}");

                if (segmentProgress < 1f)
                {
                    Debug.Log($"Moving, returning start position: {prevPoint.position}");
                    return prevPoint.position; // 이동 중에는 출발점 좌표
                }
                else
                {
                    Debug.Log($"Arrived, returning end position: {nextPoint.position}");
                    return nextPoint.position; // 도착했으면 도착점 좌표
                }
            }
        }

        Debug.Log($"After last point, returning {timeline[timeline.Count - 1].position}");
        return timeline[timeline.Count - 1].position;
    }

    /// <summary>
    /// 모든 캐릭터 타임라인에서 의미있는 시간 지점들 추출
    /// </summary>
    private HashSet<float> GetAllTimePoints(Dictionary<string, List<TimePosition>> timelines)
{
    var timePoints = new HashSet<float>();
    
    // 기존 타임라인 지점들 추가
    foreach (var timeline in timelines.Values)
    {
        foreach (var point in timeline)
        {
            timePoints.Add(point.time);
        }
    }
    
    // 최대 시간 계산
    float maxTime = 0f;
    foreach (var timeline in timelines.Values)
    {
        if (timeline.Count > 0)
        {
            float lastTime = timeline[timeline.Count - 1].time;
            if (lastTime > maxTime) maxTime = lastTime;
        }
    }
    
    // 0.2초 간격으로 중간 지점들 추가
    for (float t = 0f; t <= maxTime; t += 0.2f)
    {
        timePoints.Add(t);
    }
    
    return timePoints;
}
    /// <summary>
    /// 특정 시간에 모든 캐릭터의 위치 계산
    /// </summary>
    private Dictionary<string, Vector3Int> GetPositionsAtTime(
        Dictionary<string, List<TimePosition>> timelines, float time)
    {
        var positions = new Dictionary<string, Vector3Int>();

        foreach (var kvp in timelines)
        {
            string characterId = kvp.Key;
            var timeline = kvp.Value;

            Vector3Int position = GetPositionAtTime(timeline, time);
            positions[characterId] = position;
        }

        return positions;
    }

    /// <summary>
    /// 특정 시간에 충돌 검사
    /// </summary>
    private CollisionEvent? CheckCollisionAtTime(Dictionary<string, Vector3Int> positions, float time)
    {
        var positionGroups = new Dictionary<Vector3Int, List<string>>();

        // 같은 위치에 있는 캐릭터들 그룹화
        foreach (var kvp in positions)
        {
            string characterId = kvp.Key;
            Vector3Int position = kvp.Value;

            if (!positionGroups.ContainsKey(position))
                positionGroups[position] = new List<string>();

            positionGroups[position].Add(characterId);
        }

        // 2명 이상이 같은 위치에 있으면 충돌
        foreach (var kvp in positionGroups)
        {
            if (kvp.Value.Count > 1)
            {
                return new CollisionEvent(time, kvp.Key, kvp.Value);
            }
        }

        return null;
    }

    /// <summary>
    /// 시간별 위치 정보 구조체
    /// </summary>
    [System.Serializable]
    private struct TimePosition
    {
        public float time;
        public Vector3Int position;

        public TimePosition(float t, Vector3Int pos)
        {
            time = t;
            position = pos;
        }
    }

    /// <summary>
    /// 디버그: 충돌 예측 결과 출력
    /// </summary>
    public void DebugPrintCollisions(List<CollisionEvent> collisions)
    {
        if (collisions.Count == 0)
        {
            Debug.Log("No collisions predicted!");
            return;
        }

        Debug.Log($"Predicted {collisions.Count} collision events:");
        foreach (var collision in collisions)
        {
            Debug.Log($"Time {collision.time:F2}s at {collision.position}: " +
                     $"{string.Join(", ", collision.characterIds)}");
        }
    }
}using UnityEngine;

/// <summary>
/// 캐릭터의 기본 동작과 상태를 관리하는 컨트롤러
/// </summary>
public class GamePiece : MonoBehaviour
{
    [Header("Character Info")]
    [SerializeField] private string characterId;
    [SerializeField] private int maxSelections = 3;
    [SerializeField] private Color characterColor = Color.red;

    [Header("Movement")]
    [SerializeField] private float moveSpeed = 2f;
    [SerializeField] private Vector3Int currentGridPosition;
    [SerializeField] private Vector3Int startGridPosition; // 시작 위치 저장

    [Header("Visual")]
    [SerializeField] private SpriteRenderer spriteRenderer;
    [SerializeField] private bool isSelected = false;

    [Header("Completion State")]
    [SerializeField] private bool isCompleted = false;

  

    // 상태 관리
    private bool isMoving = false;
    private int remainingSelections;

    // 참조
    private GridVisualizer gridVisualizer;

    void Awake()
    {
        // 컴포넌트 자동 할당
        if (spriteRenderer == null)
            spriteRenderer = GetComponent<SpriteRenderer>();

        gridVisualizer = FindFirstObjectByType<GridVisualizer>();

        remainingSelections = maxSelections;
    }

    void Start()
    {
        // 초기 설정
        SetupCharacter();
        UpdateVisual();
    }

    /// <summary>
    /// 캐릭터 초기 설정
    /// </summary>
    public void Initialize(string id, Vector3Int startPos, int maxSel, Color color, float speed = 2f)
    {
        characterId = id;
        currentGridPosition = startPos;
        startGridPosition = startPos; // 시작 위치 저장
        maxSelections = maxSel;
        remainingSelections = maxSel;
        characterColor = color;
        moveSpeed = speed;

        SetupCharacter();
        UpdateVisual();
    }

    /// <summary>
    /// 경로 완성 상태 설정
    /// </summary>
    public void SetCompleted(bool completed)
    {
        isCompleted = completed;
        UpdateVisual();
    }

    /// <summary>
    /// 완성 상태 확인
    /// </summary>
    public bool IsCompleted()
    {
        return isCompleted;
    }
    /// <summary>
    /// 시작 위치 반환
    /// </summary>
    public Vector3Int GetStartGridPosition()
    {
        return startGridPosition;
    }

    /// <summary>
    /// 현재 위치 업데이트 (이동 완료 시 호출)
    /// </summary>
    public void UpdateGridPosition(Vector3Int newPosition)
    {
        currentGridPosition = newPosition;
    }
    /// <summary>
    /// 캐릭터 기본 설정 적용
    /// </summary>
    private void SetupCharacter()
    {
        gameObject.name = $"Character_{characterId}";

        // 그리드 좌표를 월드 좌표로 변환하여 위치 설정
        if (gridVisualizer != null)
        {
            Vector3 worldPos = gridVisualizer.GridToWorldPosition(currentGridPosition);
            transform.position = worldPos;
        }

        // 스프라이트 렌더러 설정
        if (spriteRenderer != null)
        {
            spriteRenderer.color = characterColor;
            spriteRenderer.sortingOrder = 10; // 타일보다 위에 표시
        }
    }

    /// <summary>
    /// 시각적 표현 업데이트 (선택 상태 등)
    /// </summary>
    /// <summary>
    /// 시각적 표현 업데이트 (선택 상태 등)
    /// </summary>
    private void UpdateVisual()
    {
        if (spriteRenderer == null) return;

        // 완료된 캐릭터는 반투명 상태 유지
        if (isCompleted)
        {
            Color color = characterColor;
            color.a = 0.5f;
            spriteRenderer.color = color;
            transform.localScale = Vector3.one; // 크기 변화 없음
            return;
        }

        // 선택된 상태일 때 더 밝게 표시
        if (isSelected)
        {
            spriteRenderer.color = characterColor * 1.3f;
            transform.localScale = Vector3.one * 1.1f;
        }
        else
        {
            spriteRenderer.color = characterColor;
            transform.localScale = Vector3.one;
        }
    }

    /// <summary>
    /// 캐릭터 선택/해제
    /// </summary>
    public void SetSelected(bool selected)
    {
        isSelected = selected;
        UpdateVisual();
    }


    /// <summary>
    /// 남은 선택 횟수 반환
    /// </summary>
    public int GetRemainingSelections()
    {
        return remainingSelections;
    }

    /// <summary>
    /// 현재 그리드 위치 반환
    /// </summary>
    public Vector3Int GetCurrentGridPosition()
    {
        return currentGridPosition;
    }

    /// <summary>
    /// 캐릭터 ID 반환
    /// </summary>
    public string GetCharacterId()
    {
        return characterId;
    }

    /// <summary>
    /// 이동 중인지 확인
    /// </summary>
    /// 
    /// /// <summary>
    /// 원래 최대 선택 횟수 반환
    /// </summary>
    public int GetMaxSelections()
    {
        return maxSelections;
    }
    public bool IsMoving()
    {
        return isMoving;
    }

    /// <summary>
    /// 디버그 정보 출력
    /// </summary>
    public void LogCharacterInfo()
    {
        Debug.Log($"Character {characterId}: Position({currentGridPosition}), Remaining({remainingSelections}), Moving({isMoving})");
    }

#if UNITY_EDITOR
    void OnDrawGizmosSelected()
    {
        // 에디터에서 선택시 현재 위치에 기즈모 표시
        Gizmos.color = characterColor;
        Gizmos.DrawWireSphere(transform.position, 0.3f);

        // 그리드 위치 정보 표시
        UnityEditor.Handles.Label(transform.position + Vector3.up * 0.7f,
            $"{characterId}\n({currentGridPosition.x},{currentGridPosition.y})\nSel: {remainingSelections}");
    }
#endif
}using UnityEngine;
using UnityEngine.UI;
using TMPro;

/// <summary>
/// 선택된 캐릭터의 정보를 UI로 표시하는 시스템
/// </summary>
public class CharacterUIManager : MonoBehaviour
{
    [Header("UI References")]
    [SerializeField] private GameObject characterInfoPanel;
    [SerializeField] private TextMeshProUGUI characterIdText;
    [SerializeField] private TextMeshProUGUI maxSelectionsText;
    [SerializeField] private TextMeshProUGUI remainingSelectionsText;

    [Header("UI Settings")]
    [SerializeField] private bool showPanel = true;
    [SerializeField] private float panelFadeSpeed = 2f;

    // 현재 표시 중인 캐릭터
    private GamePiece currentCharacter;

    // 참조
    private TouchInputManager touchInputManager;
    private PathSelectionManager pathSelectionManager;

    // UI 애니메이션용
    private CanvasGroup panelCanvasGroup;
    private bool isPanelVisible = false;

    void Awake()
    {
        touchInputManager = FindFirstObjectByType<TouchInputManager>();
        pathSelectionManager = FindFirstObjectByType<PathSelectionManager>();

        // CanvasGroup 컴포넌트 확인/추가
        if (characterInfoPanel != null)
        {
            panelCanvasGroup = characterInfoPanel.GetComponent<CanvasGroup>();
            if (panelCanvasGroup == null)
                panelCanvasGroup = characterInfoPanel.AddComponent<CanvasGroup>();

            // 초기에는 숨김
            characterInfoPanel.SetActive(false);
            panelCanvasGroup.alpha = 0f;
        }
    }

    void Start()
    {
        // 초기 UI 상태 설정
        HideCharacterInfo();
    }

    void Update()
    {
        // 선택된 캐릭터 정보 실시간 업데이트
        UpdateCharacterInfo();

        // 패널 페이드 애니메이션
        UpdatePanelAnimation();
    }

    /// <summary>
    /// 캐릭터 정보 실시간 업데이트
    /// </summary>
    /// <summary>
    /// 캐릭터 정보 실시간 업데이트
    /// </summary>
    private void UpdateCharacterInfo()
    {
        if (touchInputManager == null) return;

        GamePiece selectedCharacter = touchInputManager.GetSelectedCharacter();

        // 선택된 캐릭터가 변경되었을 때
        if (currentCharacter != selectedCharacter)
        {
            currentCharacter = selectedCharacter;

            if (currentCharacter != null)
            {
                ShowCharacterInfo();
            }
            else
            {
                HideCharacterInfo();
            }
        }

        // 현재 캐릭터가 완료되었으면 UI 숨기기
        if (currentCharacter != null && currentCharacter.IsCompleted())
        {
            HideCharacterInfo();
            currentCharacter = null;
            return;
        }

        // 선택된 캐릭터가 있을 때 실시간 업데이트
        if (currentCharacter != null && isPanelVisible)
        {
            UpdateSelectionCounts();
        }
    }

    /// <summary>
    /// 캐릭터 정보 표시
    /// </summary>
    private void ShowCharacterInfo()
    {
        if (!showPanel || characterInfoPanel == null || currentCharacter == null) return;

        // 기본 정보 설정
        if (characterIdText != null)
            characterIdText.text = $"Character: {currentCharacter.GetCharacterId()}";

        if (maxSelectionsText != null)
            maxSelectionsText.text = $"Max Selections: {currentCharacter.GetRemainingSelections()}"; // 초기값

        // 패널 표시
        characterInfoPanel.SetActive(true);
        isPanelVisible = true;

        UpdateSelectionCounts();
    }

    /// <summary>
    /// 선택 횟수 정보 업데이트
    /// </summary>
    /// <summary>
    /// 선택 횟수 정보 업데이트
    /// </summary>
    private void UpdateSelectionCounts()
    {
        if (currentCharacter == null) return;

        // 현재 사용된 선택 횟수 계산
        int usedSelections = 0;
        if (pathSelectionManager != null && pathSelectionManager.IsSelectingPath())
        {
            var currentPath = pathSelectionManager.GetCurrentPath();
            if (currentPath != null && currentPath.Count > 1)
            {
                usedSelections = currentPath.Count - 1; // 시작점 제외
            }
        }

        int maxSelections = currentCharacter.GetMaxSelections();
        int remainingSelections = maxSelections - usedSelections;

        // UI 업데이트
        if (maxSelectionsText != null)
            maxSelectionsText.text = $"Max Selections: {maxSelections}";

        if (remainingSelectionsText != null)
            remainingSelectionsText.text = $"Remaining: {remainingSelections}/{maxSelections}";
    }

    /// <summary>
    /// 캐릭터 정보 숨기기
    /// </summary>
    private void HideCharacterInfo()
    {
        isPanelVisible = false;

        if (characterInfoPanel != null)
        {
            // 페이드 아웃 애니메이션 후 비활성화
            Invoke(nameof(DeactivatePanel), 1f / panelFadeSpeed);
        }
    }

    /// <summary>
    /// 패널 비활성화
    /// </summary>
    private void DeactivatePanel()
    {
        if (characterInfoPanel != null && !isPanelVisible)
            characterInfoPanel.SetActive(false);
    }

    /// <summary>
    /// 패널 페이드 애니메이션
    /// </summary>
    private void UpdatePanelAnimation()
    {
        if (panelCanvasGroup == null) return;

        float targetAlpha = isPanelVisible ? 1f : 0f;
        float currentAlpha = panelCanvasGroup.alpha;

        if (Mathf.Abs(currentAlpha - targetAlpha) > 0.01f)
        {
            panelCanvasGroup.alpha = Mathf.MoveTowards(currentAlpha, targetAlpha, panelFadeSpeed * Time.deltaTime);
        }
    }

    /// <summary>
    /// 캐릭터 색상과 일치하는 UI 색상 적용
    /// </summary>
    private void ApplyCharacterColor()
    {
        if (currentCharacter == null) return;

        // 캐릭터의 색상 가져오기
        var characterRenderer = currentCharacter.GetComponent<SpriteRenderer>();
        if (characterRenderer != null)
        {
            Color characterColor = characterRenderer.color;

            // 텍스트 색상 적용
            if (characterIdText != null)
                characterIdText.color = characterColor;
        }
    }

    /// <summary>
    /// UI 설정 변경
    /// </summary>
    public void SetUISettings(bool showUI, float fadeSpeed = 2f)
    {
        showPanel = showUI;
        panelFadeSpeed = fadeSpeed;

        if (!showUI)
        {
            HideCharacterInfo();
        }
    }

    /// <summary>
    /// 수동으로 UI 강제 업데이트
    /// </summary>
    public void ForceUpdateUI()
    {
        UpdateCharacterInfo();
    }

#if UNITY_EDITOR
    [ContextMenu("Test Show Character Info")]
    public void TestShowCharacterInfo()
    {
        if (touchInputManager != null)
        {
            var selectedCharacter = touchInputManager.GetSelectedCharacter();
            if (selectedCharacter != null)
            {
                ShowCharacterInfo();
            }
            else
            {
                Debug.Log("No character selected for testing");
            }
        }
    }

    [ContextMenu("Test Hide Character Info")]
    public void TestHideCharacterInfo()
    {
        HideCharacterInfo();
    }
#endif
}using UnityEngine;
using UnityEngine.InputSystem;

/// <summary>
/// 터치 입력을 처리하고 캐릭터 선택을 관리하는 시스템
/// 좌표 변환 로직이 GridVisualizer와 통합되도록 수정됨
/// </summary>
public class TouchInputManager : MonoBehaviour
{
    [Header("Input Settings")]
    [SerializeField] private float touchRadius = 0.5f;
    [SerializeField] private LayerMask touchLayerMask = -1;

    [Header("Debug")]
    [SerializeField] private bool showDebugInfo = true;
    [SerializeField] private bool showTouchPosition = true;

    // 입력 시스템
    private PlayerInputActions inputActions;
    private Camera mainCamera;

    // 선택된 캐릭터
    private GamePiece selectedCharacter;

    // 참조
    private LevelLoader levelLoader;
    private GridVisualizer gridVisualizer;
    private PathSelectionManager pathSelectionManager;

    void Awake()
    {
        // 컴포넌트 참조 설정
        inputActions = new PlayerInputActions();
        mainCamera = Camera.main;
        levelLoader = FindFirstObjectByType<LevelLoader>();
        gridVisualizer = FindFirstObjectByType<GridVisualizer>();
        pathSelectionManager = FindFirstObjectByType<PathSelectionManager>();

        if (mainCamera == null)
        {
            Debug.LogError("Main Camera not found!");
        }

        if (gridVisualizer == null)
        {
            Debug.LogError("GridVisualizer not found! TouchInputManager needs GridVisualizer for coordinate conversion.");
        }
    }

    void OnEnable()
    {
        inputActions.Enable();
        inputActions.Player.TouchPress.performed += OnTouchPressed;
    }

    void OnDisable()
    {
        inputActions.Player.TouchPress.performed -= OnTouchPressed;
        inputActions.Disable();
    }

    private void OnTouchPressed(InputAction.CallbackContext context)
    {
        Vector2 touchPosition = inputActions.Player.Touch.ReadValue<Vector2>();
        ProcessTouch(touchPosition);
    }

    void OnDestroy()
    {
        inputActions?.Dispose();
    }

    /// <summary>
    /// 터치 입력 처리 (좌표 변환 로직 수정)
    /// </summary>
    private void ProcessTouch(Vector2 screenPosition)
    {
        if (mainCamera == null || gridVisualizer == null)
        {
            Debug.LogError("Required components not found!");
            return;
        }

        Vector3 worldPosition = mainCamera.ScreenToWorldPoint(new Vector3(screenPosition.x, screenPosition.y, -mainCamera.transform.position.z));
        worldPosition.z = 0;

        Vector3Int gridPosition = gridVisualizer.WorldToGridPosition(worldPosition);
        GamePiece touchedCharacter = FindCharacterAtPosition(worldPosition, gridPosition);


        if(touchedCharacter != null)
{
            if (selectedCharacter == touchedCharacter)
            {
                DeselectCharacter();
                return;
            }

            // 경로 선택 중이고 완료되지 않은 캐릭터가 선택되어 있을 때만 차단
            if (selectedCharacter != null &&
                !selectedCharacter.IsCompleted() &&
                pathSelectionManager != null &&
                pathSelectionManager.IsSelectingPath())
            {
                return; // 차단
            }

            SelectCharacter(touchedCharacter);
        }
        else
        {
            if (selectedCharacter != null && pathSelectionManager != null && pathSelectionManager.IsSelectingPath())
            {
                pathSelectionManager.SelectPosition(gridPosition);
            }
        }
    }
    /// <summary>
    /// 특정 위치에서 캐릭터 찾기 (검증 강화)
    /// </summary>
    private GamePiece FindCharacterAtPosition(Vector3 worldPosition, Vector3Int gridPosition)
    {
        if (levelLoader == null) return null;

        // 방법 1: 그리드 좌표로 정확히 찾기 (우선순위)
        GamePiece characterAtGrid = levelLoader.GetCharacterAt(gridPosition);
        if (characterAtGrid != null && !characterAtGrid.IsCompleted()) // 완료된 캐릭터는 선택 불가
        {
            if (showDebugInfo)
            {
                Debug.Log($"Found character {characterAtGrid.GetCharacterId()} at exact grid position {gridPosition}");
            }
            return characterAtGrid;
        }

        // 방법 2: 터치 반경 내에서 찾기 (관대한 터치)
        var allCharacters = levelLoader.GetSpawnedCharacters();
        GamePiece closestCharacter = null;
        float closestDistance = float.MaxValue;

        foreach (var character in allCharacters)
        {
            if (character.IsCompleted()) continue; // 완료된 캐릭터는 제외

            float distance = Vector3.Distance(worldPosition, character.transform.position);
            if (distance <= touchRadius && distance < closestDistance)
            {
                closestCharacter = character;
                closestDistance = distance;
            }
        }

        if (closestCharacter != null && showDebugInfo)
        {
            Debug.Log($"Found character {closestCharacter.GetCharacterId()} within touch radius. Distance: {closestDistance:F2}");
        }

        return closestCharacter;
    }
    /// <summary>
    /// 캐릭터 선택 가능 여부 확인
    /// </summary>
    private bool CanSelectCharacter(GamePiece character)
    {
        if (character == null) return false;

        // 이동 중인 캐릭터는 선택 불가
        if (character.IsMoving())
        {
            Debug.Log($"Character {character.GetCharacterId()} is currently moving and cannot be selected");
            return false;
        }

        // 남은 선택 횟수가 없으면 선택 불가
        if (character.GetRemainingSelections() <= 0)
        {
            Debug.Log($"Character {character.GetCharacterId()} has no remaining selections");
            return false;
        }

        // 다른 캐릭터가 경로 선택 중일 때의 제약 검사
        if (pathSelectionManager != null && pathSelectionManager.IsSelectingPath())
        {
            var currentSelectingCharacter = pathSelectionManager.GetCurrentCharacter();
            if (currentSelectingCharacter != null && currentSelectingCharacter != character)
            {
                Debug.Log($"Cannot select character {character.GetCharacterId()} while {currentSelectingCharacter.GetCharacterId()} is selecting path");
                return false;
            }
        }

        return true;
    }

    /// <summary>
    /// 캐릭터 선택이 차단되었을 때의 피드백
    /// </summary>
    private void ShowCharacterSelectionBlocked(GamePiece character)
    {
        if (Application.isMobilePlatform)
        {
            Handheld.Vibrate();
        }

        Debug.Log($"Character {character.GetCharacterId()} selection blocked");

        // 시각적 피드백 (예: 캐릭터 주변에 빨간 테두리 효과)
        StartCoroutine(ShowBlockedSelectionEffect(character));
    }

    /// <summary>
    /// 선택 차단 시각 효과
    /// </summary>
    private System.Collections.IEnumerator ShowBlockedSelectionEffect(GamePiece character)
    {
        if (character == null) yield break;

        // 기존 색상 백업
        var spriteRenderer = character.GetComponent<SpriteRenderer>();
        if (spriteRenderer == null) yield break;

        Color originalColor = spriteRenderer.color;
        Color blockedColor = Color.red;

        // 색상 깜빡임 효과
        float duration = 0.5f;
        int blinkCount = 3;

        for (int i = 0; i < blinkCount; i++)
        {
            // 빨간색으로
            spriteRenderer.color = blockedColor;
            yield return new WaitForSeconds(duration / (blinkCount * 2));

            // 원래 색으로
            spriteRenderer.color = originalColor;
            yield return new WaitForSeconds(duration / (blinkCount * 2));
        }
    }

    /// <summary>
    /// 캐릭터 선택 처리
    /// </summary>
    private void SelectCharacter(GamePiece character)
    {
        // 이미 선택된 캐릭터와 같다면 선택 해제
        if (selectedCharacter == character)
        {
            DeselectCharacter();
            return;
        }

        // 기존 선택 해제
        if (selectedCharacter != null)
        {
            selectedCharacter.SetSelected(false);
        }

        // 새 캐릭터 선택
        selectedCharacter = character;
        selectedCharacter.SetSelected(true);

        if (showDebugInfo)
        {
            Debug.Log($"Character {selectedCharacter.GetCharacterId()} selected");
            selectedCharacter.LogCharacterInfo();
        }

        // PathSelectionManager에게 경로 선택 시작 요청
        if (pathSelectionManager != null)
        {
            pathSelectionManager.StartPathSelection(selectedCharacter);
        }

        // 선택된 캐릭터의 목표 Goal 강조
        HighlightAssignedGoal();
    }

    /// <summary>
    /// 캐릭터 선택 해제
    /// </summary>
    private void DeselectCharacter()
    {
        if (selectedCharacter != null)
        {
            selectedCharacter.SetSelected(false);

            if (showDebugInfo)
            {
                Debug.Log($"Character {selectedCharacter.GetCharacterId()} deselected");
            }

            selectedCharacter = null;
        }

        if (pathSelectionManager != null)
        {
            pathSelectionManager.EndPathSelection();
        }

        ClearGoalHighlight();

    }

    /// <summary>
    /// 선택된 캐릭터의 목표 Goal 강조
    /// </summary>
    private void HighlightAssignedGoal()
    {
        if (selectedCharacter == null || levelLoader == null) return;

        // 모든 Goal을 기본 크기(1.0f)로 복원
        var allGoals = levelLoader.GetSpawnedGoals();
        foreach (var goal in allGoals)
        {
            goal.transform.localScale = Vector3.one;
        }

        // 선택된 캐릭터가 사용할 수 있는 Goal만 크게 만들기
        foreach (var goal in allGoals)
        {
            if (goal.CanUseGoal(selectedCharacter.GetCharacterId()))
            {
                goal.transform.localScale = Vector3.one * 1.2f;
            }
        }
    }

    /// <summary>
    /// 모든 Goal 하이라이트 해제
    /// </summary>
    private void ClearGoalHighlight()
    {
        if (levelLoader == null) return;

        var allGoals = levelLoader.GetSpawnedGoals();
        foreach (var goal in allGoals)
        {
            goal.transform.localScale = Vector3.one; // 모든 Goal을 기본 크기로
        }
    }

    /// <summary>
    /// 현재 선택된 캐릭터 반환
    /// </summary>
    public GamePiece GetSelectedCharacter()
    {
        return selectedCharacter;
    }

    /// <summary>
    /// 특정 캐릭터 강제 선택
    /// </summary>
    public void ForceSelectCharacter(GamePiece character)
    {
        if (character != null && CanSelectCharacter(character))
        {
            SelectCharacter(character);
        }
    }

    /// <summary>
    /// 모든 선택 해제
    /// </summary>
    public void ClearSelection()
    {
        DeselectCharacter();
    }

    /// <summary>
    /// 입력 시스템 활성/비활성화 (게임 상태 관리용)
    /// </summary>
    public void SetInputEnabled(bool enabled)
    {
        if (enabled)
            inputActions?.Enable();
        else
            inputActions?.Disable();
    }

#if UNITY_EDITOR
    void OnDrawGizmos()
    {
        if (showTouchPosition && mainCamera != null)
        {
            // 터치 반경 표시
            Gizmos.color = Color.yellow;
            Gizmos.DrawWireSphere(transform.position, touchRadius);
        }

        // 선택된 캐릭터 주변에 기즈모 표시
        if (selectedCharacter != null)
        {
            Gizmos.color = Color.green;
            Gizmos.DrawWireSphere(selectedCharacter.transform.position, touchRadius);
        }
    }

    [ContextMenu("Test Character Selection")]
    public void TestCharacterSelection()
    {
        if (levelLoader != null)
        {
            var characters = levelLoader.GetSpawnedCharacters();
            if (characters.Count > 0)
            {
                SelectCharacter(characters[0]);
            }
        }
    }

    [ContextMenu("Clear All Selections")]
    public void TestClearSelection()
    {
        ClearSelection();
    }
}
#endifusing System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 캐릭터 이동을 시뮬레이션하여 시간별 위치를 계산하는 시스템
/// 충돌 감지를 위한 정확한 위치 추적을 제공합니다
/// </summary>
public class MovementSimulator : MonoBehaviour
{
    [Header("Movement Settings")]
    [SerializeField] private float defaultMoveSpeed = 2f;
    [SerializeField] private AnimationCurve movementCurve = AnimationCurve.Linear(0, 0, 1, 1);

    [Header("Simulation Settings")]
    [SerializeField] private bool useSmoothing = true;
    [SerializeField] private float pauseTimeAtWaypoint = 0.1f; // 경로점에서 잠시 정지 시간

    // 참조
    private GridVisualizer gridVisualizer;
    private LevelData currentLevelData;

    void Awake()
    {
        gridVisualizer = FindFirstObjectByType<GridVisualizer>();
    }

    /// <summary>
    /// 레벨 데이터 설정
    /// </summary>
    public void SetLevelData(LevelData levelData)
    {
        currentLevelData = levelData;
        if (currentLevelData != null)
            defaultMoveSpeed = currentLevelData.moveSpeed;
    }

    /// <summary>
    /// 경로를 따라 시간별 위치를 시뮬레이션
    /// </summary>
    public List<Vector3> SimulateMovement(List<Vector3Int> gridPath, float timeStep, float? customSpeed = null)
    {
        if (gridPath == null || gridPath.Count < 2)
            return new List<Vector3>();

        float moveSpeed = customSpeed ?? defaultMoveSpeed;
        var timeline = new List<Vector3>();

        // 그리드 좌표를 월드 좌표로 변환
        var worldPath = ConvertToWorldPath(gridPath);

        // 각 구간별 이동 시뮬레이션
        Vector3 currentPosition = worldPath[0];
        timeline.Add(currentPosition);

        float totalTime = 0f;

        for (int i = 0; i < worldPath.Count - 1; i++)
        {
            Vector3 startPos = worldPath[i];
            Vector3 endPos = worldPath[i + 1];

            // 구간별 이동 시뮬레이션
            var segmentTimeline = SimulateSegmentMovement(startPos, endPos, moveSpeed, timeStep, totalTime);

            // 첫 번째 위치는 중복이므로 제외 (이전 구간의 마지막 위치)
            for (int j = 1; j < segmentTimeline.Count; j++)
            {
                timeline.Add(segmentTimeline[j]);
                totalTime += timeStep;
            }

            // 경로점에서 잠시 정지 (마지막 구간이 아닌 경우)
            if (i < worldPath.Count - 2 && pauseTimeAtWaypoint > 0)
            {
                int pauseSteps = Mathf.RoundToInt(pauseTimeAtWaypoint / timeStep);
                for (int pause = 0; pause < pauseSteps; pause++)
                {
                    timeline.Add(endPos);
                    totalTime += timeStep;
                }
            }
        }

        return timeline;
    }

    /// <summary>
    /// 두 지점 간의 이동을 시간별로 시뮬레이션
    /// </summary>
    private List<Vector3> SimulateSegmentMovement(Vector3 startPos, Vector3 endPos, float speed, float timeStep, float startTime)
    {
        var segmentTimeline = new List<Vector3>();

        float distance = Vector3.Distance(startPos, endPos);
        float totalMoveTime = distance / speed;

        if (totalMoveTime <= 0)
        {
            segmentTimeline.Add(startPos);
            segmentTimeline.Add(endPos);
            return segmentTimeline;
        }

        int steps = Mathf.CeilToInt(totalMoveTime / timeStep) + 1;

        for (int step = 0; step < steps; step++)
        {
            float t = Mathf.Clamp01((step * timeStep) / totalMoveTime);

            Vector3 position;
            if (useSmoothing)
            {
                // 애니메이션 커브 적용
                float smoothT = movementCurve.Evaluate(t);
                position = Vector3.Lerp(startPos, endPos, smoothT);
            }
            else
            {
                // 선형 보간
                position = Vector3.Lerp(startPos, endPos, t);
            }

            segmentTimeline.Add(position);
        }

        // 마지막 위치가 정확히 목표점이 되도록 보장
        if (segmentTimeline.Count > 0)
            segmentTimeline[segmentTimeline.Count - 1] = endPos;

        return segmentTimeline;
    }

    /// <summary>
    /// 그리드 경로를 월드 좌표 경로로 변환
    /// </summary>
    private List<Vector3> ConvertToWorldPath(List<Vector3Int> gridPath)
    {
        var worldPath = new List<Vector3>();

        foreach (var gridPos in gridPath)
        {
            Vector3 worldPos;
            if (gridVisualizer != null)
            {
                worldPos = gridVisualizer.GridToWorldPosition(gridPos);
            }
            else
            {
                // GridVisualizer가 없는 경우 기본 변환
                worldPos = new Vector3(gridPos.x, gridPos.y, 0);
            }
            worldPath.Add(worldPos);
        }

        return worldPath;
    }

    /// <summary>
    /// 특정 시간에서의 캐릭터 위치 계산 (단일 쿼리용)
    /// </summary>
    public Vector3 GetPositionAtTime(List<Vector3Int> gridPath, float targetTime, float? customSpeed = null)
    {
        var timeline = SimulateMovement(gridPath, 0.1f, customSpeed);

        if (timeline.Count == 0)
            return Vector3.zero;

        int timeIndex = Mathf.RoundToInt(targetTime / 0.1f);

        if (timeIndex >= timeline.Count)
            return timeline[timeline.Count - 1]; // 경로 완료 후에는 마지막 위치

        return timeline[Mathf.Max(0, timeIndex)];
    }

    /// <summary>
    /// 경로의 총 이동 시간 계산
    /// </summary>
    public float CalculateTotalMoveTime(List<Vector3Int> gridPath, float? customSpeed = null)
    {
        if (gridPath == null || gridPath.Count < 2)
            return 0f;

        float moveSpeed = customSpeed ?? defaultMoveSpeed;
        var worldPath = ConvertToWorldPath(gridPath);
        float totalTime = 0f;

        for (int i = 0; i < worldPath.Count - 1; i++)
        {
            float distance = Vector3.Distance(worldPath[i], worldPath[i + 1]);
            totalTime += distance / moveSpeed;

            // 경로점에서의 정지 시간 추가 (마지막 구간이 아닌 경우)
            if (i < worldPath.Count - 2)
                totalTime += pauseTimeAtWaypoint;
        }

        return totalTime;
    }

    /// <summary>
    /// 두 캐릭터의 이동 타임라인을 비교하여 가장 가까운 거리의 시점 찾기
    /// </summary>
    public float FindClosestApproachTime(List<Vector3Int> path1, List<Vector3Int> path2, float timeStep = 0.1f)
    {
        var timeline1 = SimulateMovement(path1, timeStep);
        var timeline2 = SimulateMovement(path2, timeStep);

        float closestTime = 0f;
        float minDistance = float.MaxValue;

        int maxSteps = Mathf.Max(timeline1.Count, timeline2.Count);

        for (int i = 0; i < maxSteps; i++)
        {
            Vector3 pos1 = i < timeline1.Count ? timeline1[i] : timeline1[timeline1.Count - 1];
            Vector3 pos2 = i < timeline2.Count ? timeline2[i] : timeline2[timeline2.Count - 1];

            float distance = Vector3.Distance(pos1, pos2);
            if (distance < minDistance)
            {
                minDistance = distance;
                closestTime = i * timeStep;
            }
        }

        return closestTime;
    }

    /// <summary>
    /// 경로의 각 구간별 속도를 다르게 설정하여 시뮬레이션 (고급 기능)
    /// </summary>
    public List<Vector3> SimulateMovementWithVariableSpeed(List<Vector3Int> gridPath, List<float> segmentSpeeds, float timeStep)
    {
        if (gridPath == null || gridPath.Count < 2 || segmentSpeeds == null || segmentSpeeds.Count != gridPath.Count - 1)
            return SimulateMovement(gridPath, timeStep);

        var timeline = new List<Vector3>();
        var worldPath = ConvertToWorldPath(gridPath);

        Vector3 currentPosition = worldPath[0];
        timeline.Add(currentPosition);
        float totalTime = 0f;

        for (int i = 0; i < worldPath.Count - 1; i++)
        {
            Vector3 startPos = worldPath[i];
            Vector3 endPos = worldPath[i + 1];
            float segmentSpeed = segmentSpeeds[i];

            var segmentTimeline = SimulateSegmentMovement(startPos, endPos, segmentSpeed, timeStep, totalTime);

            for (int j = 1; j < segmentTimeline.Count; j++)
            {
                timeline.Add(segmentTimeline[j]);
                totalTime += timeStep;
            }
        }

        return timeline;
    }

    /// <summary>
    /// 디버그용: 시뮬레이션 결과 시각화
    /// </summary>
    public void DebugDrawMovementPreview(List<Vector3Int> gridPath, float previewDuration = 2f)
    {
        if (gridPath == null || gridPath.Count < 2) return;

        var timeline = SimulateMovement(gridPath, 0.1f);

        // 경로 라인 그리기
        var worldPath = ConvertToWorldPath(gridPath);
        for (int i = 0; i < worldPath.Count - 1; i++)
        {
            Debug.DrawLine(worldPath[i], worldPath[i + 1], Color.green, previewDuration);
        }

        // 시작점과 끝점 표시
        if (worldPath.Count > 0)
        {
            Debug.DrawRay(worldPath[0], Vector3.up * 0.5f, Color.blue, previewDuration);
            Debug.DrawRay(worldPath[worldPath.Count - 1], Vector3.up * 0.5f, Color.red, previewDuration);
        }

        Debug.Log($"Movement simulation: {timeline.Count} time steps, Total time: {CalculateTotalMoveTime(gridPath):F2}s");
    }

#if UNITY_EDITOR
    [ContextMenu("Test Movement Simulation")]
    public void TestMovementSimulation()
    {
        var testPath = new List<Vector3Int>
        {
            new Vector3Int(0, 0, 0),
            new Vector3Int(3, 0, 0),
            new Vector3Int(3, 3, 0)
        };

        Debug.Log("Testing movement simulation...");
        DebugDrawMovementPreview(testPath, 5f);

        float totalTime = CalculateTotalMoveTime(testPath);
        Debug.Log($"Total movement time: {totalTime:F2} seconds");
    }
#endif
}using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 캐릭터 간 충돌을 감지하는 시스템
/// 경로 기반으로 실제 충돌 가능성을 미리 계산합니다
/// </summary>
public class CollisionDetector : MonoBehaviour
{
    [Header("Collision Settings")]
    [SerializeField] private float timeStep = 0.1f; // 시뮬레이션 시간 단위
    [SerializeField] private bool enableDebugMode = true;

    // 참조
    private LevelLoader levelLoader;
    private MovementSimulator movementSimulator;

    void Awake()
    {
        levelLoader = FindFirstObjectByType<LevelLoader>();
        movementSimulator = GetComponent<MovementSimulator>();

        if (movementSimulator == null)
            movementSimulator = gameObject.AddComponent<MovementSimulator>();
    }

    /// <summary>
    /// 충돌 결과 데이터
    /// </summary>
    [System.Serializable]
    public struct CollisionResult
    {
        public bool hasCollision;
        public Vector3Int collisionPosition;
        public float collisionTime;
        public List<string> involvedCharacters;
        public string collisionType; // "head-on", "same-tile", "crossing"

        public CollisionResult(bool collision, Vector3Int position = default, float time = 0f,
                              List<string> characters = null, string type = "unknown")
        {
            hasCollision = collision;
            collisionPosition = position;
            collisionTime = time;
            involvedCharacters = characters ?? new List<string>();
            collisionType = type;
        }
    }

    /// <summary>
    /// 모든 캐릭터의 경로를 검사하여 충돌 가능성을 확인
    /// </summary>
    public CollisionResult CheckAllCollisions(Dictionary<string, List<Vector3Int>> characterPaths)
    {
        if (characterPaths == null || characterPaths.Count < 2)
            return new CollisionResult(false);

        // 각 캐릭터의 시간별 위치 시뮬레이션
        var characterTimelines = new Dictionary<string, List<Vector3>>();
        float maxTime = 0f;

        foreach (var kvp in characterPaths)
        {
            string characterId = kvp.Key;
            List<Vector3Int> path = kvp.Value;

            if (path == null || path.Count < 2) continue;

            var timeline = movementSimulator.SimulateMovement(path, timeStep);
            characterTimelines[characterId] = timeline;

            float pathTime = (timeline.Count - 1) * timeStep;
            if (pathTime > maxTime) maxTime = pathTime;
        }

        // 시간별로 충돌 검사
        return CheckTimelineCollisions(characterTimelines, maxTime);
    }

    /// <summary>
    /// 두 캐릭터 간의 충돌만 검사 (빠른 검사용)
    /// </summary>
    public CollisionResult CheckTwoCharacterCollision(string characterId1, List<Vector3Int> path1,
                                                      string characterId2, List<Vector3Int> path2)
    {
        var paths = new Dictionary<string, List<Vector3Int>>
        {
            { characterId1, path1 },
            { characterId2, path2 }
        };

        return CheckAllCollisions(paths);
    }

    /// <summary>
    /// 시간별 위치 데이터를 바탕으로 충돌 검사
    /// </summary>
    private CollisionResult CheckTimelineCollisions(Dictionary<string, List<Vector3>> timelines, float maxTime)
    {
        int maxTimeSteps = Mathf.CeilToInt(maxTime / timeStep) + 1;

        for (int timeIndex = 0; timeIndex < maxTimeSteps; timeIndex++)
        {
            float currentTime = timeIndex * timeStep;
            var positionsAtTime = new Dictionary<string, Vector3>();

            // 현재 시간에서 각 캐릭터의 위치 계산
            foreach (var kvp in timelines)
            {
                string characterId = kvp.Key;
                List<Vector3> timeline = kvp.Value;

                if (timeIndex < timeline.Count)
                {
                    positionsAtTime[characterId] = timeline[timeIndex];
                }
                else if (timeline.Count > 0)
                {
                    // 경로 완료 후에는 마지막 위치에 머물러 있음
                    positionsAtTime[characterId] = timeline[timeline.Count - 1];
                }
            }

            // 현재 시간에서 위치 충돌 검사
            var collision = CheckPositionCollisions(positionsAtTime, currentTime);
            if (collision.hasCollision)
                return collision;
        }

        return new CollisionResult(false);
    }

    /// <summary>
    /// 특정 시간에서 캐릭터들의 위치 충돌 검사
    /// </summary>
    private CollisionResult CheckPositionCollisions(Dictionary<string, Vector3> positions, float time)
    {
        var characterIds = new List<string>(positions.Keys);

        for (int i = 0; i < characterIds.Count; i++)
        {
            for (int j = i + 1; j < characterIds.Count; j++)
            {
                string char1 = characterIds[i];
                string char2 = characterIds[j];

                Vector3 pos1 = positions[char1];
                Vector3 pos2 = positions[char2];

                // 실제 충돌 판단 (거리 기반)
                float distance = Vector3.Distance(pos1, pos2);
                if (distance < 0.3f) // 충돌 임계값
                {
                    Vector3Int gridCollisionPos = new Vector3Int(
                        Mathf.RoundToInt((pos1.x + pos2.x) / 2f),
                        Mathf.RoundToInt((pos1.y + pos2.y) / 2f),
                        0
                    );

                    var involvedCharacters = new List<string> { char1, char2 };
                    string collisionType = DetermineCollisionType(pos1, pos2);

                    if (enableDebugMode)
                    {
                        Debug.Log($"Collision detected at time {time:F1}s between {char1} and {char2}");
                        Debug.Log($"Positions: {char1}({pos1}) vs {char2}({pos2}), Distance: {distance:F2}");
                        Debug.Log($"Collision Type: {collisionType}");
                    }

                    return new CollisionResult(
                        true,
                        gridCollisionPos,
                        time,
                        involvedCharacters,
                        collisionType
                    );
                }
            }
        }

        return new CollisionResult(false);
    }

    /// <summary>
    /// 충돌 타입 결정 (정면충돌, 교차, 동일타일점유 등)
    /// </summary>
    private string DetermineCollisionType(Vector3 pos1, Vector3 pos2)
    {
        float distance = Vector3.Distance(pos1, pos2);

        if (distance < 0.1f)
            return "same-tile";
        else if (distance < 0.5f)
            return "close-proximity";
        else
            return "crossing";
    }

    /// <summary>
    /// 특정 캐릭터의 경로가 다른 캐릭터들과 충돌하는지 검사
    /// </summary>
    public CollisionResult CheckSingleCharacterPath(string characterId, List<Vector3Int> newPath)
    {
        if (levelLoader == null) return new CollisionResult(false);

        var allCharacters = levelLoader.GetSpawnedCharacters();
        var allPaths = new Dictionary<string, List<Vector3Int>>();

        // 다른 캐릭터들의 현재 경로 수집 (실제 구현 시 경로 저장소에서 가져와야 함)
        foreach (var character in allCharacters)
        {
            if (character.GetCharacterId() == characterId)
            {
                allPaths[characterId] = newPath;
            }
            else
            {
                // TODO: 다른 캐릭터들의 설정된 경로를 가져오는 로직 필요
                // 현재는 시작점만 포함하는 기본 경로로 설정
                var basicPath = new List<Vector3Int> { character.GetCurrentGridPosition() };
                allPaths[character.GetCharacterId()] = basicPath;
            }
        }

        return CheckAllCollisions(allPaths);
    }

    /// <summary>
    /// 충돌 결과를 사용자에게 표시하기 위한 메시지 생성
    /// </summary>
    public string GetCollisionMessage(CollisionResult result)
    {
        if (!result.hasCollision)
            return "No collision detected.";

        string characterList = string.Join(" and ", result.involvedCharacters);
        return $"Collision between {characterList} at {result.collisionPosition} " +
               $"(Time: {result.collisionTime:F1}s, Type: {result.collisionType})";
    }

    /// <summary>
    /// 디버그용: 충돌 시뮬레이션 결과를 시각화
    /// </summary>
    public void DebugDrawCollisionPreview(CollisionResult result)
    {
        if (!enableDebugMode || !result.hasCollision) return;

        // Scene 뷰에서 충돌 지점 표시
        Debug.DrawRay(
            new Vector3(result.collisionPosition.x, result.collisionPosition.y, 0),
            Vector3.up * 0.5f,
            Color.red,
            2f
        );

        Debug.Log(GetCollisionMessage(result));
    }

    /// <summary>
    /// 충돌 감지 설정
    /// </summary>
    public void SetCollisionSettings(float newTimeStep, bool debugMode)
    {
        timeStep = Mathf.Clamp(newTimeStep, 0.05f, 1f);
        enableDebugMode = debugMode;
    }

#if UNITY_EDITOR
    [ContextMenu("Test Collision Detection")]
    public void TestCollisionDetection()
    {
        // 테스트용 경로 생성
        var testPaths = new Dictionary<string, List<Vector3Int>>
        {
            { "A", new List<Vector3Int> { new Vector3Int(0, 0, 0), new Vector3Int(1, 0, 0), new Vector3Int(2, 0, 0) } },
            { "B", new List<Vector3Int> { new Vector3Int(2, 2, 0), new Vector3Int(2, 1, 0), new Vector3Int(2, 0, 0) } }
        };

        var result = CheckAllCollisions(testPaths);
        Debug.Log($"Test Result: {GetCollisionMessage(result)}");
        DebugDrawCollisionPreview(result);
    }
#endif
}using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 경로 검증을 담당하는 시스템
/// 타일 존재 여부, 장애물, 경로 유효성을 검사합니다
/// </summary>
public class PathValidator : MonoBehaviour
{
    // 참조
    private GridVisualizer gridVisualizer;
    private LevelLoader levelLoader;
    private LevelData currentLevelData;

    void Awake()
    {
        gridVisualizer = FindFirstObjectByType<GridVisualizer>();
        levelLoader = FindFirstObjectByType<LevelLoader>();
    }

    void Start()
    {
        // LevelLoader에서 현재 레벨 데이터 가져오기
        if (levelLoader != null)
        {
            // LevelLoader에 CurrentLevelData 프로퍼티 추가 필요
            // currentLevelData = levelLoader.GetCurrentLevelData();
        }
    }

    /// <summary>
    /// 레벨 데이터 설정 (LevelLoader에서 호출)
    /// </summary>
    public void SetLevelData(LevelData levelData)
    {
        currentLevelData = levelData;
    }

    /// <summary>
    /// 특정 위치가 이동 가능한지 확인
    /// </summary>
    public bool IsValidPosition(Vector3Int position)
    {
        // 그리드 범위 확인
        if (gridVisualizer != null && !gridVisualizer.IsValidGridPosition(position))
            return false;

        // 타일 존재 확인
        if (!HasTileAt(position))
            return false;

        return true;
    }

    /// <summary>
    /// 특정 위치에 타일이 있는지 확인
    /// </summary>
    public bool HasTileAt(Vector3Int position)
    {
        if (currentLevelData == null)
        {
            Debug.LogWarning("LevelData is not set in PathValidator");
            return false;
        }

        return currentLevelData.HasTileAt(position);
    }

    /// <summary>
    /// 특정 위치에 장애물이 있는지 확인
    /// </summary>
    public bool HasObstacleAt(Vector3Int position, GamePiece excludeCharacter = null)
    {
        if (levelLoader == null) return false;

        // 모든 캐릭터 위치는 장애물 (본인 포함)
        var characterAtPosition = levelLoader.GetCharacterAt(position);
        if (characterAtPosition != null)
            return true;

        // 다른 목적지가 있는지 확인 (본인 목적지가 아닌 경우)
        var goalAtPosition = levelLoader.GetGoalAt(position);
        if (goalAtPosition != null && excludeCharacter != null)
        {
            // 현재 캐릭터가 사용할 수 없는 목적지라면 장애물로 처리
            if (!goalAtPosition.CanUseGoal(excludeCharacter.GetCharacterId()))
            {
                return true;
            }
        }

        // 타일이 없으면 장애물로 간주
        if (!HasTileAt(position))
            return true;

        return false;
    }

    /// <summary>
    /// 두 위치 사이의 직선 경로에 장애물이 있는지 확인
    /// </summary>
    public bool HasObstacleInPath(Vector3Int fromPos, Vector3Int toPos, GamePiece excludeCharacter = null)
    {
        // 동서남북이 아닌 경우 무효
        if (fromPos.x != toPos.x && fromPos.y != toPos.y)
            return true;

        Vector3Int diff = toPos - fromPos;
        Vector3Int direction = new Vector3Int(
            diff.x == 0 ? 0 : (diff.x > 0 ? 1 : -1),
            diff.y == 0 ? 0 : (diff.y > 0 ? 1 : -1),
            0
        );

        Vector3Int currentPos = fromPos + direction;

        // 경로상의 모든 타일 검사
        while (currentPos != toPos)
        {
            if (HasObstacleAt(currentPos, excludeCharacter))
                return true;
            currentPos += direction;
        }

        // 목표 위치도 검사
        return HasObstacleAt(toPos, excludeCharacter);
    }

    /// <summary>
    /// 캐릭터가 특정 방향으로 이동 가능한 최대 거리 계산
    /// </summary>
    public List<Vector3Int> GetValidPositionsInDirection(Vector3Int startPos, Vector3Int direction, GamePiece character)
    {
        List<Vector3Int> validPositions = new List<Vector3Int>();
        Vector3Int currentPos = startPos;

        for (int i = 1; i <= 100; i++) // 충분히 큰 값 (또는 while(true)로 무한)
        {
            Vector3Int nextPos = currentPos + direction * i;

            // 유효하지 않은 위치면 중단
            if (!IsValidPosition(nextPos))
                break;

            // 장애물이 있으면 중단
            if (HasObstacleAt(nextPos, character))
                break;

            validPositions.Add(nextPos);

            // 목적지에 도달하면 중단
            if (IsGoalPosition(nextPos, character))
                break;
        }

        return validPositions;
    }

    /// <summary>
    /// 특정 위치가 캐릭터의 목적지인지 확인
    /// </summary>
    public bool IsGoalPosition(Vector3Int position, GamePiece character)
    {
        if (levelLoader == null || character == null) return false;

        var availableGoals = GetAvailableGoalsForCharacter(character);
        foreach (var goal in availableGoals)
        {
            if (goal.GetGridPosition() == position)
                return true;
        }
        return false;
    }

    /// <summary>
    /// 캐릭터가 사용할 수 있는 목적지들 반환
    /// </summary>
    public List<GoalController> GetAvailableGoalsForCharacter(GamePiece character)
    {
        List<GoalController> availableGoals = new List<GoalController>();

        if (character == null || levelLoader == null) return availableGoals;

        var allGoals = levelLoader.GetSpawnedGoals();
        string characterId = character.GetCharacterId();

        foreach (var goal in allGoals)
        {
            if (goal.CanUseGoal(characterId))
            {
                availableGoals.Add(goal);
            }
        }

        return availableGoals;
    }

    /// <summary>
    /// 마지막-1 선택에서 목적지와 직선거리상에 있는 위치만 필터링
    /// </summary>
    public List<Vector3Int> FilterLastSelectionPositions(List<Vector3Int> positions, GamePiece character)
    {
        List<Vector3Int> filteredPositions = new List<Vector3Int>();

        var availableGoals = GetAvailableGoalsForCharacter(character);

        foreach (Vector3Int pos in positions)
        {
            foreach (var goal in availableGoals)
            {
                Vector3Int goalPos = goal.GetGridPosition();
                // 직선거리상에 있는지 확인 (수평 또는 수직)
                if (pos.x == goalPos.x || pos.y == goalPos.y)
                {
                    // 해당 위치에서 목적지까지 경로에 장애물이 없는지 확인
                    if (!HasObstacleInPath(pos, goalPos, character))
                    {
                        filteredPositions.Add(pos);
                        break;
                    }
                }
            }
        }

        return filteredPositions;
    }

    /// <summary>
    /// 전체 경로의 유효성 검사
    /// </summary>
    public bool ValidateCompletePath(List<Vector3Int> path, GamePiece character)
    {
        if (path == null || path.Count < 2 || character == null)
            return false;

        // 각 구간별 유효성 검사
        for (int i = 0; i < path.Count - 1; i++)
        {
            Vector3Int fromPos = path[i];
            Vector3Int toPos = path[i + 1];

            // 직선 이동인지 확인
            if (fromPos.x != toPos.x && fromPos.y != toPos.y)
            {
                Debug.LogWarning($"Invalid path: diagonal movement from {fromPos} to {toPos}");
                return false;
            }

            // 경로상에 장애물이 있는지 확인
            if (HasObstacleInPath(fromPos, toPos, character))
            {
                Debug.LogWarning($"Invalid path: obstacle in path from {fromPos} to {toPos}");
                return false;
            }
        }

        // 마지막 위치가 목적지인지 확인
        Vector3Int finalPos = path[path.Count - 1];
        if (!IsGoalPosition(finalPos, character))
        {
            Debug.LogWarning($"Invalid path: final position {finalPos} is not a valid goal for character {character.GetCharacterId()}");
            return false;
        }

        return true;
    }

    /// <summary>
    /// 디버그용: 경로 정보 출력
    /// </summary>
    public void DebugLogPath(List<Vector3Int> path, string pathName = "Path")
    {
        if (path == null || path.Count == 0)
        {
            Debug.Log($"{pathName}: Empty or null");
            return;
        }

        string pathString = string.Join(" -> ", path);
        Debug.Log($"{pathName}: {pathString} (Length: {path.Count})");

        // 각 구간의 유효성도 체크
        for (int i = 0; i < path.Count - 1; i++)
        {
            Vector3Int from = path[i];
            Vector3Int to = path[i + 1];
            bool hasObstacle = HasObstacleInPath(from, to);
            Debug.Log($"  Segment {i}: {from} -> {to}, HasObstacle: {hasObstacle}");
        }
    }
}using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 캐릭터의 경로 선택을 관리하는 시스템
/// PathValidator, CollisionDetector, MovementSimulator와 연동
/// 완성된 경로를 저장하여 MovementGameManager에 전달
/// </summary>
public class PathSelectionManager : MonoBehaviour
{
    [Header("Visual Settings")]
    [SerializeField] private Material pathLineMaterial;
    [SerializeField] private Color availablePathColor = Color.yellow;
    [SerializeField] private Color selectedPathColor = Color.green;
    [SerializeField] private Color invalidPathColor = Color.red;
    [SerializeField] private float lineWidth = 0.1f;

    [Header("Flag Settings")]
    [SerializeField] private GameObject flagPrefab;
    [SerializeField] private float flagScale = 0.5f;

    [Header("Collision Feedback")]
    //[SerializeField] private bool showCollisionWarnings = true;

    // 현재 선택된 캐릭터
    private GamePiece currentCharacter;

    // 경로 관리
    private List<Vector3Int> currentPath = new List<Vector3Int>();
    private List<GameObject> pathFlags = new List<GameObject>();
    private List<LineRenderer> availablePathLines = new List<LineRenderer>();
    private LineRenderer finalPathLine;

    // 완성된 경로들을 저장하는 딕셔너리 (새로 추가)
    private Dictionary<string, List<Vector3Int>> completedPaths = new Dictionary<string, List<Vector3Int>>();

    // 시스템 참조
    private PathValidator pathValidator;
    private CollisionDetector collisionDetector;
    private MovementSimulator movementSimulator;
    private GridVisualizer gridVisualizer;
    private LevelLoader levelLoader;
    private TouchInputManager touchInputManager;

    void Awake()
    {
        // 기존 참조
        gridVisualizer = FindFirstObjectByType<GridVisualizer>();
        levelLoader = FindFirstObjectByType<LevelLoader>();
        touchInputManager = FindFirstObjectByType<TouchInputManager>();

        // 새 시스템 참조 (같은 GameObject에 있다고 가정)
        pathValidator = GetComponent<PathValidator>();
        collisionDetector = GetComponent<CollisionDetector>();
        movementSimulator = GetComponent<MovementSimulator>();

        // 없으면 자동 생성
        if (pathValidator == null)
            pathValidator = gameObject.AddComponent<PathValidator>();
        if (collisionDetector == null)
            collisionDetector = gameObject.AddComponent<CollisionDetector>();
        if (movementSimulator == null)
            movementSimulator = gameObject.AddComponent<MovementSimulator>();

        // 최종 경로 Line Renderer 생성
        CreateFinalPathLineRenderer();

        if (gridVisualizer == null)
            Debug.LogError("GridVisualizer not found!");
        if (levelLoader == null)
            Debug.LogError("LevelLoader not found!");
    }

    /// <summary>
    /// 캐릭터 선택 시 경로 선택 모드 시작
    /// </summary>
    public void StartPathSelection(GamePiece character)
    {
        if (character == null) return;

        currentCharacter = character;
        currentPath.Clear();

        // 캐릭터 시작 위치를 경로에 추가
        currentPath.Add(character.GetCurrentGridPosition());

        // 가능한 경로들 표시
        ShowAvailablePaths();
    }

    /// <summary>
    /// 경로 선택 모드 종료
    /// </summary>
    public void EndPathSelection()
    {
        currentCharacter = null;
        currentPath.Clear();

        ClearAllVisuals();
    }

    /// <summary>
    /// 특정 위치 선택 처리
    /// </summary>
    public void SelectPosition(Vector3Int gridPosition)
    {
        if (currentCharacter == null) return;

        Vector3Int currentPos = currentPath.Count > 0 ? currentPath[currentPath.Count - 1] : currentCharacter.GetCurrentGridPosition();

        // 선택 가능한 위치인지 확인
        if (!IsValidSelection(currentPos, gridPosition))
        {
            ShowInvalidSelectionFeedback(gridPosition);
            return;
        }

        // 경로에 추가
        currentPath.Add(gridPosition);

        // Flag 생성
        CreateFlag(gridPosition);

        // 남은 선택 횟수 확인
        int remainingSelections = currentCharacter.GetRemainingSelections() - (currentPath.Count - 1);

        if (remainingSelections <= 0 || pathValidator.IsGoalPosition(gridPosition, currentCharacter))
        {
            // 경로 완성
            CompletePath();
        }
        else
        {
            // 다음 선택을 위한 가능한 경로 업데이트
            ShowAvailablePaths();
        }
    }

    /// <summary>
    /// 유효한 선택인지 확인
    /// </summary>
    private bool IsValidSelection(Vector3Int fromPos, Vector3Int toPos)
    {
        // 기본 검증
        if (fromPos.x != toPos.x && fromPos.y != toPos.y) return false;
        if (fromPos == toPos) return false;

        // 경로 유효성 검사
        if (!pathValidator.IsValidPosition(toPos) ||
            pathValidator.HasObstacleInPath(fromPos, toPos, currentCharacter))
            return false;

        // 현재 표시된 노란 라인 범위 내에서만 선택 가능
        Vector3Int direction = new Vector3Int(
            toPos.x > fromPos.x ? 1 : (toPos.x < fromPos.x ? -1 : 0),
            toPos.y > fromPos.y ? 1 : (toPos.y < fromPos.y ? -1 : 0),
            0
        );

        var validPositions = pathValidator.GetValidPositionsInDirection(fromPos, direction, currentCharacter);
        if (!validPositions.Contains(toPos))
            return false;

        int remaining = currentCharacter.GetRemainingSelections() - (currentPath.Count - 1);

        // 마지막 선택일 때는 반드시 Goal이어야 함
        if (remaining == 1)
        {
            return pathValidator.IsGoalPosition(toPos, currentCharacter);
        }

        // 마지막-1 선택일 때는 Goal과 직선상에 있어야 함
        if (remaining == 2)
        {
            var availableGoals = pathValidator.GetAvailableGoalsForCharacter(currentCharacter);
            foreach (var goal in availableGoals)
            {
                Vector3Int goalPos = goal.GetGridPosition();
                if ((toPos.x == goalPos.x || toPos.y == goalPos.y) &&
                    !pathValidator.HasObstacleInPath(toPos, goalPos, currentCharacter))
                {
                    return true;
                }
            }
            return false;
        }

        // 마지막-2 선택일 때 추가 검증
        if (remaining == 3)
        {
            // 해당 위치에서 한 번 더 이동했을 때 Goal과 직선상인 유효한 위치가 있는지 확인
            bool canReachGoalLine = false;
            var availableGoals = pathValidator.GetAvailableGoalsForCharacter(currentCharacter);

            Vector3Int[] directions = { Vector3Int.up, Vector3Int.down, Vector3Int.left, Vector3Int.right };

            foreach (var dir in directions)
            {
                var nextPositions = pathValidator.GetValidPositionsInDirection(toPos, dir, currentCharacter);

                foreach (var nextPos in nextPositions)
                {
                    // 다음 위치가 Goal과 직선상에 있는지 확인
                    foreach (var goal in availableGoals)
                    {
                        Vector3Int goalPos = goal.GetGridPosition();
                        if ((nextPos.x == goalPos.x || nextPos.y == goalPos.y) &&
                            !pathValidator.HasObstacleInPath(nextPos, goalPos, currentCharacter))
                        {
                            canReachGoalLine = true;
                            break;
                        }
                    }
                    if (canReachGoalLine) break;
                }
                if (canReachGoalLine) break;
            }

            if (!canReachGoalLine) return false;
        }

        return true;
    }

    /// <summary>
    /// 현재 위치에서 가능한 모든 경로 표시
    /// </summary>
    private void ShowAvailablePaths()
    {
        // 기존 라인들 정리
        ClearAvailablePathLines();

        if (currentCharacter == null || currentPath.Count == 0) return;

        Vector3Int currentPos = currentPath[currentPath.Count - 1];
        int remainingSelections = currentCharacter.GetRemainingSelections() - (currentPath.Count - 1);

        if (remainingSelections <= 0) return;

        // 동서남북 방향 확인
        Vector3Int[] directions = { Vector3Int.up, Vector3Int.down, Vector3Int.left, Vector3Int.right };

        foreach (Vector3Int direction in directions)
        {
            ShowDirectionPath(currentPos, direction, remainingSelections);
        }
    }

    /// <summary>
    /// 특정 방향으로 가능한 경로 표시
    /// </summary>
    private void ShowDirectionPath(Vector3Int startPos, Vector3Int direction, int remainingSelections)
    {
        // PathValidator를 사용하여 해당 방향의 유효한 위치들 가져오기
        List<Vector3Int> pathPositions = pathValidator.GetValidPositionsInDirection(startPos, direction, currentCharacter);

        // 마지막 선택 (remainingSelections == 1): Goal만 표시
        if (remainingSelections == 1)
        {
            // Goal 위치만 필터링
            List<Vector3Int> goalOnlyPositions = new List<Vector3Int>();
            var availableGoals = pathValidator.GetAvailableGoalsForCharacter(currentCharacter);

            foreach (var goal in availableGoals)
            {
                Vector3Int goalPos = goal.GetGridPosition();
                if (pathPositions.Contains(goalPos))
                {
                    goalOnlyPositions.Add(goalPos);
                }
            }
            pathPositions = goalOnlyPositions;
        }
        // 마지막-1 선택 (remainingSelections == 2): Goal과 직선상인 곳만
        else if (remainingSelections == 2)
        {
            pathPositions = pathValidator.FilterLastSelectionPositions(pathPositions, currentCharacter);
        }

        if (pathPositions.Count > 0)
        {
            CreateAvailablePathLine(startPos, pathPositions);
        }
    }

    /// <summary>
    /// 가능한 경로 Line Renderer 생성
    /// </summary>
    private void CreateAvailablePathLine(Vector3Int startPos, List<Vector3Int> pathPositions)
    {
        GameObject lineObj = new GameObject("AvailablePath");
        LineRenderer line = lineObj.AddComponent<LineRenderer>();

        line.material = pathLineMaterial;
        line.startColor = availablePathColor;
        line.endColor = availablePathColor;
        line.startWidth = lineWidth;
        line.endWidth = lineWidth;
        line.positionCount = pathPositions.Count + 1;
        line.sortingOrder = 15;
        line.useWorldSpace = true;

        // 시작점 설정
        Vector3 startWorldPos = gridVisualizer.GridToWorldPosition(startPos);
        line.SetPosition(0, startWorldPos);

        // 경로 점들 설정
        for (int i = 0; i < pathPositions.Count; i++)
        {
            Vector3 worldPos = gridVisualizer.GridToWorldPosition(pathPositions[i]);
            line.SetPosition(i + 1, worldPos);
        }

        availablePathLines.Add(line);
    }

    /// <summary>
    /// 경로 완성 처리
    /// </summary>
    private void CompletePath()
    {
        if (currentCharacter == null) return;

        ClearAvailablePathLines();
        ShowFinalPath();
        SetCharacterCompleted(currentCharacter); // 먼저 완료 설정
        SaveCompletedPathToMemory(); // 경로 저장 및 알림

        // Goal 크기 복원
        if (levelLoader != null)
        {
            var allGoals = levelLoader.GetSpawnedGoals();
            foreach (var goal in allGoals)
            {
                if (goal.CanUseGoal(currentCharacter.GetCharacterId()))
                {
                    goal.transform.localScale = Vector3.one;
                }
            }
        }

        // 선택 상태 정리는 마지막에
        currentCharacter = null;
        currentPath.Clear();

        // 시각적 정리만 1초 후
        Invoke(nameof(VisualOnlyCleanup), 1f);
    }

    /// <summary>
    /// 완성된 경로를 메모리에 저장 (이동 시스템에서 사용)
    /// </summary>
    private void SaveCompletedPathToMemory()
    {
        if (currentCharacter == null || currentPath.Count < 2) return;

        string characterId = currentCharacter.GetCharacterId();
        completedPaths[characterId] = new List<Vector3Int>(currentPath);

        Debug.Log($"Saved path for {characterId}: {string.Join(" -> ", currentPath)}");

        // MovementGameManager에게 경로 완성 알림
        NotifyPathCompleted();
    }

    /// <summary>
    /// MovementGameManager에게 경로 완성 알림
    /// </summary>
    private void NotifyPathCompleted()
    {

        var gameManager = FindFirstObjectByType<MovementGameManager>();


        if (gameManager != null)
        {
            gameManager.OnPathCompleted();
        }
        else
        {
        }
    }

    /// <summary>
    /// 모든 완성된 경로 반환
    /// </summary>
    public Dictionary<string, List<Vector3Int>> GetCompletedPaths()
    {
        return new Dictionary<string, List<Vector3Int>>(completedPaths);
    }

    /// <summary>
    /// 특정 캐릭터의 완성된 경로 반환
    /// </summary>
    public List<Vector3Int> GetCompletedPath(string characterId)
    {
        if (completedPaths.ContainsKey(characterId))
            return new List<Vector3Int>(completedPaths[characterId]);
        return null;
    }

    /// <summary>
    /// 모든 경로 초기화
    /// </summary>
    public void ClearAllCompletedPaths()
    {
        completedPaths.Clear();
    }

    /// <summary>
    /// 잘못된 선택에 대한 피드백 표시
    /// </summary>
    private void ShowInvalidSelectionFeedback(Vector3Int gridPosition)
    {
        // 진동 또는 사운드 효과 (모바일)
        if (Application.isMobilePlatform)
        {
            Handheld.Vibrate();
        }

        // 시각적 피드백
        StartCoroutine(ShowInvalidPositionEffect(gridPosition));

        Debug.Log($"Invalid selection at {gridPosition}");
    }

    /// <summary>
    /// 잘못된 위치 선택 시 시각 효과
    /// </summary>
    private System.Collections.IEnumerator ShowInvalidPositionEffect(Vector3Int gridPosition)
    {
        if (gridVisualizer == null) yield break;

        // 빨간색 임시 마커 생성
        GameObject tempMarker = new GameObject("InvalidMarker");
        tempMarker.transform.position = gridVisualizer.GridToWorldPosition(gridPosition);

        var renderer = tempMarker.AddComponent<SpriteRenderer>();
        renderer.sprite = CreateSimpleSquareSprite();
        renderer.color = invalidPathColor;
        renderer.sortingOrder = 25;

        // 크기 애니메이션
        Vector3 originalScale = Vector3.one * 0.5f;
        Vector3 targetScale = Vector3.one * 1.2f;

        float duration = 0.3f;
        float elapsed = 0f;

        while (elapsed < duration)
        {
            float t = elapsed / duration;
            tempMarker.transform.localScale = Vector3.Lerp(originalScale, targetScale, t);
            renderer.color = Color.Lerp(invalidPathColor, Color.clear, t);

            elapsed += Time.deltaTime;
            yield return null;
        }

        Destroy(tempMarker);
    }

    /// <summary>
    /// 간단한 정사각형 스프라이트 생성 (임시 마커용)
    /// </summary>
    private Sprite CreateSimpleSquareSprite()
    {
        Texture2D texture = new Texture2D(32, 32);
        Color[] pixels = new Color[32 * 32];
        for (int i = 0; i < pixels.Length; i++)
            pixels[i] = Color.white;

        texture.SetPixels(pixels);
        texture.Apply();

        return Sprite.Create(texture, new Rect(0, 0, 32, 32), Vector2.one * 0.5f);
    }

    /// <summary>
    /// 캐릭터를 완료 상태로 설정
    /// </summary>
    private void SetCharacterCompleted(GamePiece character)
    {
        character.SetCompleted(true);
    }

    private void VisualOnlyCleanup()
    {
        ClearFinalPath();
        ClearFlags();
    }

    /// <summary>
    /// Flag 생성
    /// </summary>
    private void CreateFlag(Vector3Int gridPosition)
    {
        if (flagPrefab == null) return;

        Vector3 worldPos = gridVisualizer.GridToWorldPosition(gridPosition);
        GameObject flag = Instantiate(flagPrefab, worldPos, Quaternion.identity);
        flag.transform.localScale = Vector3.one * flagScale;
        flag.name = $"Flag_{pathFlags.Count}";

        pathFlags.Add(flag);
    }

    /// <summary>
    /// 최종 경로 표시
    /// </summary>
    private void ShowFinalPath()
    {
        if (finalPathLine == null || currentPath.Count < 2) return;

        finalPathLine.gameObject.SetActive(true);
        finalPathLine.positionCount = currentPath.Count;

        for (int i = 0; i < currentPath.Count; i++)
        {
            Vector3 worldPos = gridVisualizer.GridToWorldPosition(currentPath[i]);
            finalPathLine.SetPosition(i, worldPos);
        }
    }

    /// <summary>
    /// 최종 경로 라인 생성
    /// </summary>
    private void CreateFinalPathLineRenderer()
    {
        GameObject finalLineObj = new GameObject("FinalPath");
        finalLineObj.transform.SetParent(transform);

        finalPathLine = finalLineObj.AddComponent<LineRenderer>();
        finalPathLine.material = pathLineMaterial;
        finalPathLine.startColor = selectedPathColor;
        finalPathLine.endColor = selectedPathColor;
        finalPathLine.startWidth = lineWidth * 1.5f;
        finalPathLine.endWidth = lineWidth * 1.5f;
        finalPathLine.sortingOrder = 20;
        finalPathLine.useWorldSpace = true;
        finalPathLine.gameObject.SetActive(false);
    }

    /// <summary>
    /// 모든 시각적 요소 정리
    /// </summary>
    private void ClearAllVisuals()
    {
        ClearAvailablePathLines();
        ClearFlags();
        ClearFinalPath();
    }

    /// <summary>
    /// 가능한 경로 라인들 정리
    /// </summary>
    private void ClearAvailablePathLines()
    {
        foreach (var line in availablePathLines)
        {
            if (line != null)
                DestroyImmediate(line.gameObject);
        }
        availablePathLines.Clear();
    }

    /// <summary>
    /// Flag들 정리
    /// </summary>
    private void ClearFlags()
    {
        foreach (var flag in pathFlags)
        {
            if (flag != null)
                DestroyImmediate(flag.gameObject);
        }
        pathFlags.Clear();
    }

    /// <summary>
    /// 최종 경로 라인 정리
    /// </summary>
    private void ClearFinalPath()
    {
        if (finalPathLine != null)
            finalPathLine.gameObject.SetActive(false);
    }

    /// <summary>
    /// 현재 경로 반환
    /// </summary>
    public List<Vector3Int> GetCurrentPath()
    {
        return new List<Vector3Int>(currentPath);
    }

    /// <summary>
    /// 경로 선택 중인지 확인
    /// </summary>
    public bool IsSelectingPath()
    {
        return currentCharacter != null && currentPath.Count > 0;
    }

    /// <summary>
    /// 현재 선택된 캐릭터 반환
    /// </summary>
    public GamePiece GetCurrentCharacter()
    {
        return currentCharacter;
    }
}using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;

public class LevelLoader : MonoBehaviour
{
    [Header("Level Data")]
    [SerializeField] private LevelData[] levelDataArray;
    [SerializeField] private int currentLevelIndex = 0;

    [Header("Prefabs")]
    [SerializeField] private GameObject characterPrefab;
    [SerializeField] private GameObject goalPrefab;

    [Header("Runtime Objects")]
    [SerializeField] private Transform charactersParent;
    [SerializeField] private Transform goalsParent;

    [Header("Tilemap References")]
    [SerializeField] private Tilemap targetTilemap;
    [SerializeField] private Grid targetGrid;

    private List<GamePiece> spawnedCharacters = new List<GamePiece>();
    private List<GoalController> spawnedGoals = new List<GoalController>();
    private LevelData currentLevelData;

    private GridVisualizer gridVisualizer;
    private PathValidator pathValidator;
    private CollisionDetector collisionDetector;
    private MovementSimulator movementSimulator;
    private TestUIManager testUIManager;

    void Awake()
    {
        gridVisualizer = FindFirstObjectByType<GridVisualizer>();
        pathValidator = FindFirstObjectByType<PathValidator>();
        collisionDetector = FindFirstObjectByType<CollisionDetector>();
        movementSimulator = FindFirstObjectByType<MovementSimulator>();
        testUIManager = FindFirstObjectByType<TestUIManager>();

        if (charactersParent == null)
        {
            GameObject charactersContainer = new GameObject("Characters");
            charactersParent = charactersContainer.transform;
        }

        if (goalsParent == null)
        {
            GameObject goalsContainer = new GameObject("Goals");
            goalsParent = goalsContainer.transform;
        }

        if (targetTilemap == null)
            targetTilemap = FindFirstObjectByType<Tilemap>();
        if (targetGrid == null)
            targetGrid = FindFirstObjectByType<Grid>();
    }

    void Start()
    {
        LoadCurrentLevel();
    }

    private void LoadCurrentLevel()
    {
        if (levelDataArray == null || levelDataArray.Length == 0)
        {
            Debug.LogError("No level data assigned!");
            return;
        }

        if (currentLevelIndex >= levelDataArray.Length)
        {
            Debug.LogError($"Level index {currentLevelIndex} out of range!");
            return;
        }

        LoadLevel(levelDataArray[currentLevelIndex]);
    }

    public void LoadNextLevel()
    {
        if (levelDataArray == null || levelDataArray.Length == 0) return;

        currentLevelIndex++;

        if (currentLevelIndex >= levelDataArray.Length)
        {
            currentLevelIndex = levelDataArray.Length - 1;

            if (testUIManager != null)
            {
                testUIManager.ShowAllLevelsCompleted();
            }
            return;
        }

        LoadCurrentLevel();
    }

    public void RestartCurrentLevel()
    {
        LoadCurrentLevel();
    }

    public void LoadLevel(LevelData levelData)
    {
        if (levelData == null)
        {
            Debug.LogError("LevelData is null!");
            return;
        }

        var gameManager = FindFirstObjectByType<MovementGameManager>();
        if (gameManager != null)
        {
            gameManager.OnLevelChanged();
        }

        ClearCurrentLevel();
        currentLevelData = levelData;
        NotifySystemsOfLevelData();
        RestoreTilemap();
        SpawnCharacters();
        SpawnGoals();
        SetupCharacterGoalAssignments();

        if (gameManager != null)
        {
            gameManager.InitializeForNewLevel();
        }
    }

    public void OnLevelCleared()
    {
        if (testUIManager != null)
        {
            testUIManager.ShowLevelClearedUI();
        }
    }

    public void OnGameOver(string message)
    {
        if (testUIManager != null)
        {
            testUIManager.ShowGameOverUI(message);
        }
    }

    private void RestoreTilemap()
    {
        if (currentLevelData == null || targetTilemap == null) return;

        ClearExistingTilemap();

        foreach (var tileData in currentLevelData.walkableTiles)
        {
            TileBase tileAsset = currentLevelData.GetTileAsset(tileData.tileTypeId);

            if (tileAsset != null)
            {
                targetTilemap.SetTile(tileData.position, tileAsset);
            }
        }

        if (targetGrid != null)
        {
            targetGrid.cellSize = new Vector3(currentLevelData.cellSize, currentLevelData.cellSize, 1f);
            targetGrid.transform.position = currentLevelData.gridOrigin;
        }

        targetTilemap.CompressBounds();
    }

    private void ClearExistingTilemap()
    {
        if (targetTilemap == null) return;

        BoundsInt bounds = targetTilemap.cellBounds;

        if (bounds.size.x > 0 && bounds.size.y > 0)
        {
            TileBase[] emptyTiles = new TileBase[bounds.size.x * bounds.size.y * bounds.size.z];
            targetTilemap.SetTilesBlock(bounds, emptyTiles);
        }

        targetTilemap.CompressBounds();
    }

    private void NotifySystemsOfLevelData()
    {
        if (pathValidator != null)
        {
            pathValidator.SetLevelData(currentLevelData);
        }

        if (movementSimulator != null)
        {
            movementSimulator.SetLevelData(currentLevelData);
        }
    }

    private void ClearCurrentLevel()
    {
        foreach (var character in spawnedCharacters)
        {
            if (character != null)
                DestroyImmediate(character.gameObject);
        }
        spawnedCharacters.Clear();

        foreach (var goal in spawnedGoals)
        {
            if (goal != null)
                DestroyImmediate(goal.gameObject);
        }
        spawnedGoals.Clear();
    }

    private void SpawnCharacters()
    {
        if (characterPrefab == null) return;

        foreach (var characterData in currentLevelData.characters)
        {
            Vector3 worldPosition = gridVisualizer != null
                ? gridVisualizer.GridToWorldPosition(characterData.startPosition)
                : new Vector3(characterData.startPosition.x, characterData.startPosition.y, 0);

            GameObject characterObj = Instantiate(characterPrefab, worldPosition, Quaternion.identity, charactersParent);

            GamePiece gamePiece = characterObj.GetComponent<GamePiece>();
            if (gamePiece == null)
            {
                gamePiece = characterObj.AddComponent<GamePiece>();
            }

            Color characterColor = characterData.characterColor;
            if (characterColor.a == 0)
            {
                characterColor = GetDefaultCharacterColor(characterData.characterId);
            }

            gamePiece.Initialize(
                characterData.characterId,
                characterData.startPosition,
                characterData.maxSelections,
                characterColor,
                currentLevelData.moveSpeed
            );

            spawnedCharacters.Add(gamePiece);
        }
    }

    private void SpawnGoals()
    {
        if (goalPrefab == null) return;

        for (int i = 0; i < currentLevelData.goals.Count; i++)
        {
            var goalData = currentLevelData.goals[i];

            Vector3 worldPosition = gridVisualizer != null
                ? gridVisualizer.GridToWorldPosition(goalData.position)
                : new Vector3(goalData.position.x, goalData.position.y, 0);

            GameObject goalObj = Instantiate(goalPrefab, worldPosition, Quaternion.identity, goalsParent);

            GoalController goalController = goalObj.GetComponent<GoalController>();
            if (goalController == null)
            {
                goalController = goalObj.AddComponent<GoalController>();
            }

            Color goalColor = goalData.goalColor;
            if (goalColor.a == 0)
            {
                goalColor = Color.white;
            }

            goalController.Initialize(
                i,
                goalData.position,
                goalData.goalType,
                goalColor,
                goalData.assignedCharacters
            );

            spawnedGoals.Add(goalController);
        }
    }

    private Color GetDefaultCharacterColor(string characterId)
    {
        switch (characterId)
        {
            case "A": return Color.red;
            case "B": return Color.blue;
            case "C": return Color.green;
            case "D": return Color.yellow;
            default: return Color.white;
        }
    }

    private void SetupCharacterGoalAssignments()
    {
        foreach (var character in spawnedCharacters)
        {
            string characterId = character.GetCharacterId();
            var characterData = currentLevelData.characters.Find(c => c.characterId == characterId);

            if (characterData.assignedGoalIndex >= 0 && characterData.assignedGoalIndex < spawnedGoals.Count)
            {
                spawnedGoals[characterData.assignedGoalIndex].AssignCharacter(characterId);
            }
            else
            {
                foreach (var goal in spawnedGoals)
                {
                    if (goal.GetGoalType() == GoalType.Shared || goal.GetGoalType() == GoalType.Single)
                    {
                        goal.AssignCharacter(characterId);
                    }
                }
            }
        }
    }

    public LevelData GetCurrentLevelData() => currentLevelData;
    public List<GamePiece> GetSpawnedCharacters() => new List<GamePiece>(spawnedCharacters);
    public List<GoalController> GetSpawnedGoals() => new List<GoalController>(spawnedGoals);
    public GamePiece GetCharacterAt(Vector3Int gridPosition) => spawnedCharacters.Find(c => c.GetCurrentGridPosition() == gridPosition);
    public GoalController GetGoalAt(Vector3Int gridPosition) => spawnedGoals.Find(g => g.GetGridPosition() == gridPosition);
    public GamePiece GetCharacterById(string characterId) => spawnedCharacters.Find(c => c.GetCharacterId() == characterId);
}using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 목적지의 기본 동작과 상태를 관리하는 컨트롤러
/// </summary>
public class GoalController : MonoBehaviour
{
    [Header("Goal Info")]
    [SerializeField] private int goalIndex;
    [SerializeField] private GoalType goalType = GoalType.Individual;
    [SerializeField] private Color goalColor = Color.white;

    [Header("Position")]
    [SerializeField] private Vector3Int gridPosition;

    [Header("Visual")]
    [SerializeField] private SpriteRenderer spriteRenderer;

    // 할당된 캐릭터들
    private List<string> assignedCharacterIds = new List<string>();
    private bool isOccupied = false;

    // 참조
    private GridVisualizer gridVisualizer;

    void Awake()
    {
        // 컴포넌트 자동 할당
        if (spriteRenderer == null)
            spriteRenderer = GetComponent<SpriteRenderer>();

        gridVisualizer = FindFirstObjectByType<GridVisualizer>();
    }

    void Start()
    {
        SetupGoal();
        UpdateVisual();
    }

    /// <summary>
    /// 목적지 초기 설정
    /// </summary>
    public void Initialize(int index, Vector3Int position, GoalType type, Color color, List<string> assignedCharacters = null)
    {
        goalIndex = index;
        gridPosition = position;
        goalType = type;
        goalColor = color;

        if (assignedCharacters != null)
        {
            assignedCharacterIds = new List<string>(assignedCharacters);
        }

        SetupGoal();
        UpdateVisual();
    }

    /// <summary>
    /// 목적지 기본 설정 적용
    /// </summary>
    private void SetupGoal()
    {
        gameObject.name = $"Goal_{goalIndex}_{goalType}";

        // 그리드 좌표를 월드 좌표로 변환하여 위치 설정
        if (gridVisualizer != null)
        {
            Vector3 worldPos = gridVisualizer.GridToWorldPosition(gridPosition);
            transform.position = worldPos;
        }

        // 스프라이트 렌더러 설정
        if (spriteRenderer != null)
        {
            spriteRenderer.color = goalColor;
            spriteRenderer.sortingOrder = 5; // 타일 위, 캐릭터 아래

            // 모든 Goal 기본 크기는 1.0f로 통일
            transform.localScale = Vector3.one;
        }
    }

    /// <summary>
    /// 시각적 표현 업데이트
    /// </summary>
    private void UpdateVisual()
    {
        if (spriteRenderer == null) return;

        // 점유 상태에 따라 색상 조정
        if (isOccupied)
        {
            spriteRenderer.color = goalColor * 0.7f; // 어둡게
        }
        else
        {
            spriteRenderer.color = goalColor;
        }

        // 목적지 타입에 따른 시각적 효과
        UpdateTypeVisual();
    }

    /// <summary>
    /// 목적지 타입에 따른 시각적 효과
    /// </summary>
    private void UpdateTypeVisual()
    {
        // 나중에 파티클 효과나 애니메이션 추가 가능
        switch (goalType)
        {
            case GoalType.Individual:
                // 개별 목적지는 기본 표시
                break;
            case GoalType.Shared:
                // 공유 목적지는 약간의 펄스 효과 (나중에 구현)
                break;
            case GoalType.Single:
                // 단일 목적지는 더 두드러지게 (나중에 구현)
                break;
        }
    }

    /// <summary>
    /// 특정 캐릭터가 이 목적지를 사용할 수 있는지 확인
    /// </summary>
    public bool CanUseGoal(string characterId)
    {
        switch (goalType)
        {
            case GoalType.Individual:
                // 개별 목적지: 할당된 캐릭터만 사용 가능
                return assignedCharacterIds.Contains(characterId) && !isOccupied;

            case GoalType.Shared:
                // 공유 목적지: 할당된 캐릭터들이 공유 사용
                return assignedCharacterIds.Contains(characterId);

            case GoalType.Single:
                // 단일 목적지: 모든 캐릭터가 사용 가능
                return true;
        }

        return false;
    }

    /// <summary>
    /// 캐릭터를 목적지에 할당
    /// </summary>
    public void AssignCharacter(string characterId)
    {
        if (!assignedCharacterIds.Contains(characterId))
        {
            assignedCharacterIds.Add(characterId);
            Debug.Log($"Character {characterId} assigned to Goal {goalIndex}");
        }
    }

    /// <summary>
    /// 목적지 점유 상태 설정
    /// </summary>
    public void SetOccupied(bool occupied)
    {
        isOccupied = occupied;
        UpdateVisual();
    }

    /// <summary>
    /// 현재 그리드 위치 반환
    /// </summary>
    public Vector3Int GetGridPosition()
    {
        return gridPosition;
    }

    /// <summary>
    /// 목적지 인덱스 반환
    /// </summary>
    public int GetGoalIndex()
    {
        return goalIndex;
    }

    /// <summary>
    /// 목적지 타입 반환
    /// </summary>
    public GoalType GetGoalType()
    {
        return goalType;
    }

    /// <summary>
    /// 할당된 캐릭터 목록 반환
    /// </summary>
    public List<string> GetAssignedCharacters()
    {
        return new List<string>(assignedCharacterIds);
    }

    /// <summary>
    /// 디버그 정보 출력
    /// </summary>
    public void LogGoalInfo()
    {
        Debug.Log($"Goal {goalIndex}: Position({gridPosition}), Type({goalType}), Occupied({isOccupied})");
        Debug.Log($"Assigned Characters: {string.Join(", ", assignedCharacterIds)}");
    }

#if UNITY_EDITOR
    void OnDrawGizmosSelected()
    {
        // 에디터에서 선택시 목적지 정보 표시
        Gizmos.color = goalColor;
        Gizmos.DrawWireCube(transform.position, Vector3.one * 0.9f);

        // 목적지 정보 표시
        string info = $"Goal {goalIndex}\n({gridPosition.x},{gridPosition.y})\n{goalType}";
        if (assignedCharacterIds.Count > 0)
        {
            info += $"\nAssigned: {string.Join(",", assignedCharacterIds)}";
        }

        UnityEditor.Handles.Label(transform.position + Vector3.up * 1.2f, info);
    }
#endif
}using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;

/// <summary>
/// 캐릭터 데이터를 저장하는 구조체
/// </summary>
[System.Serializable]
public struct CharacterData
{
    [Header("Character Info")]
    public string characterId;           // 캐릭터 식별자 (예: "A", "B", "C", "D")
    public Vector3Int startPosition;     // 시작 위치 (그리드 좌표)
    public int maxSelections;            // 최대 경로 선택 횟수

    [Header("Visual")]
    public Color characterColor;         // 캐릭터 색상

    [Header("Goal Assignment")]
    public int assignedGoalIndex;        // 할당된 목적지 인덱스 (-1이면 공유 목적지)

    public CharacterData(string id, Vector3Int startPos, int maxSel, Color color, int goalIndex = -1)
    {
        characterId = id;
        startPosition = startPos;
        maxSelections = maxSel;
        characterColor = color;
        assignedGoalIndex = goalIndex;
    }
}

/// <summary>
/// 목적지 데이터를 저장하는 구조체
/// </summary>
[System.Serializable]
public struct GoalData
{
    [Header("Goal Info")]
    public Vector3Int position;          // 목적지 위치 (그리드 좌표)
    public GoalType goalType;           // 목적지 타입
    public List<string> assignedCharacters; // 이 목적지에 할당된 캐릭터들

    [Header("Visual")]
    public Color goalColor;             // 목적지 색상

    public GoalData(Vector3Int pos, GoalType type, Color color)
    {
        position = pos;
        goalType = type;
        goalColor = color;
        assignedCharacters = new List<string>();
    }
}

// GoalType은 별도 파일에 정의되어 있으므로 여기서는 제거

/// <summary>
/// 타일 데이터를 저장하는 구조체 (필요 시 확장 가능)
/// </summary>
/// <summary>
/// 타일 데이터를 저장하는 구조체
/// </summary>
[System.Serializable]
public struct TileData
{
    public Vector3Int position;         // 타일 위치
    public bool isWalkable;            // 이동 가능 여부
    public string tileName;            // 타일 이름
    public int tileTypeId;             // 타일 타입 ID

    public TileData(Vector3Int pos, bool walkable = true, string name = "", int typeId = 0)
    {
        position = pos;
        isWalkable = walkable;
        tileName = name;
        tileTypeId = typeId;
    }
}

/// <summary>
/// 타일 타입 정보를 저장하는 구조체
/// </summary>
[System.Serializable]
public struct TileTypeData
{
    public int typeId;
    public string typeName;
    public string tileAssetPath;       // 타일 에셋 경로
    public bool isWalkable;

    public TileTypeData(int id, string name, string assetPath, bool walkable = true)
    {
        typeId = id;
        typeName = name;
        tileAssetPath = assetPath;
        isWalkable = walkable;
    }
}

/// <summary>
/// 레벨 데이터를 저장하는 ScriptableObject
/// </summary>
[CreateAssetMenu(fileName = "LevelData", menuName = "PuzzleGame/Level Data")]
public class LevelData : ScriptableObject
{
    [Header("Level Info")]
    public int levelNumber;
    public string levelName;

    [Header("Tile Mapping")]
    public List<TileTypeData> tileTypes = new List<TileTypeData>();  // 사용된 타일 타입들

    [Header("Tiles")]
    public List<TileData> walkableTiles = new List<TileData>();     // 실제 배치된 타일들

    [Header("Grid Settings")]
    public int gridWidth = 10;
    public int gridHeight = 10;
    public float cellSize = 1f;
    public Vector3 gridOrigin = Vector3.zero;

    [Header("Characters")]
    public List<CharacterData> characters = new List<CharacterData>();

    [Header("Goals")]
    public List<GoalData> goals = new List<GoalData>();
    
    [Header("Level Settings")]
    public float moveSpeed = 2f;        // 캐릭터 이동 속도
    public bool showGridInGame = false; // 게임 중 그리드 표시 여부

    /// <summary>
    /// 특정 위치에 타일이 있는지 확인
    /// </summary>
    public bool HasTileAt(Vector3Int position)
    {
        return walkableTiles.Exists(tile => tile.position == position && tile.isWalkable);
    }

    /// <summary>
    /// 특정 위치에 캐릭터가 있는지 확인
    /// </summary>
    /// 



    public CharacterData? GetCharacterAt(Vector3Int position)
    {
        for (int i = 0; i < characters.Count; i++)
        {
            if (characters[i].startPosition == position)
                return characters[i];
        }
        return null;
    }

    /// <summary>
    /// 특정 위치에 목적지가 있는지 확인
    /// </summary>
    public GoalData? GetGoalAt(Vector3Int position)
    {
        for (int i = 0; i < goals.Count; i++)
        {
            if (goals[i].position == position)
                return goals[i];
        }
        return null;
    }

    /// <summary>
    /// 캐릭터 추가
    /// </summary>
    public void AddCharacter(string id, Vector3Int startPos, int maxSelections, Color color, int goalIndex = -1)
    {
        characters.Add(new CharacterData(id, startPos, maxSelections, color, goalIndex));
    }

    /// <summary>
    /// 목적지 추가
    /// </summary>
    public void AddGoal(Vector3Int position, GoalType goalType, Color color)
    {
        goals.Add(new GoalData(position, goalType, color));
    }

    /// <summary>
    /// 타일 추가
    /// </summary>
    public void AddTile(Vector3Int position, bool isWalkable = true)
    {
        // 중복 체크
        if (!walkableTiles.Exists(tile => tile.position == position))
        {
            walkableTiles.Add(new TileData(position, isWalkable));
        }
    }

    /// <summary>
    /// 레벨 데이터 유효성 검사
    /// </summary>
    public bool ValidateLevelData(out string errorMessage)
    {
        errorMessage = "";

        // 캐릭터 수 체크
        if (characters.Count < 2 || characters.Count > 4)
        {
            errorMessage = "캐릭터는 2-4개 사이여야 합니다.";
            return false;
        }

        // 목적지 수 체크
        if (goals.Count == 0)
        {
            errorMessage = "최소 1개의 목적지가 필요합니다.";
            return false;
        }

        // 캐릭터 시작 위치에 타일이 있는지 확인
        foreach (var character in characters)
        {
            if (!HasTileAt(character.startPosition))
            {
                errorMessage = $"캐릭터 {character.characterId}의 시작 위치({character.startPosition})에 타일이 없습니다.";
                return false;
            }
        }

        // 목적지 위치에 타일이 있는지 확인
        foreach (var goal in goals)
        {
            if (!HasTileAt(goal.position))
            {
                errorMessage = $"목적지 위치({goal.position})에 타일이 없습니다.";
                return false;
            }
        }

        // 캐릭터와 목적지 위치 중복 체크
        HashSet<Vector3Int> usedPositions = new HashSet<Vector3Int>();

        foreach (var character in characters)
        {
            if (usedPositions.Contains(character.startPosition))
            {
                errorMessage = $"캐릭터 시작 위치가 중복됩니다: {character.startPosition}";
                return false;
            }
            usedPositions.Add(character.startPosition);
        }

        return true;
    }

    /// <summary>
    /// 레벨 데이터 클리어
    /// </summary>
    public void ClearLevelData()
    {
        characters.Clear();
        goals.Clear();
        walkableTiles.Clear();
    }

    /// <summary>
    /// 디버그 정보 출력
    /// </summary>
    public void LogLevelInfo()
    {
        Debug.Log($"=== Level {levelNumber}: {levelName} ===");
        Debug.Log($"Grid: {gridWidth}x{gridHeight}, Cell Size: {cellSize}");
        Debug.Log($"Characters: {characters.Count}, Goals: {goals.Count}, Tiles: {walkableTiles.Count}");

        foreach (var character in characters)
        {
            Debug.Log($"Character {character.characterId}: Start({character.startPosition}), MaxSel({character.maxSelections}), Goal({character.assignedGoalIndex})");
        }

        for (int i = 0; i < goals.Count; i++)
        {
            Debug.Log($"Goal {i}: Pos({goals[i].position}), Type({goals[i].goalType})");
        }
    }
    
    /// <summary>
     /// 타일 타입 ID로 실제 TileBase 에셋 로드
     /// </summary>
    public TileBase GetTileAsset(int tileTypeId)
    {
#if UNITY_EDITOR
        var tileType = tileTypes.Find(t => t.typeId == tileTypeId);
        if (!string.IsNullOrEmpty(tileType.tileAssetPath))
        {
            return UnityEditor.AssetDatabase.LoadAssetAtPath<TileBase>(tileType.tileAssetPath);
        }
#endif
        return null;
    }

    /// <summary>
    /// 타일 타입 추가
    /// </summary>
    public void AddTileType(int typeId, string typeName, string assetPath, bool isWalkable = true)
    {
        // 중복 체크
        if (!tileTypes.Exists(t => t.typeId == typeId))
        {
            tileTypes.Add(new TileTypeData(typeId, typeName, assetPath, isWalkable));
        }
    }

    /// <summary>
    /// 타일 추가 (오버로드)
    /// </summary>
    public void AddTile(Vector3Int position, bool isWalkable, string tileName, int tileTypeId)
    {
        // 중복 체크
        if (!walkableTiles.Exists(tile => tile.position == position))
        {
            walkableTiles.Add(new TileData(position, isWalkable, tileName, tileTypeId));
        }
    }

    /// <summary>
    /// 특정 타입ID의 타일 타입 정보 반환
    /// </summary>
    public TileTypeData? GetTileType(int typeId)
    {
        var tileType = tileTypes.Find(t => t.typeId == typeId);
        return tileType.typeId == typeId ? tileType : (TileTypeData?)null;
    }

}/// <summary>
/// 목적지 타입 정의
/// 이 파일을 먼저 생성해야 다른 스크립트들이 GoalType을 인식합니다
/// </summary>
public enum GoalType
{
    Individual,     // 개별 목적지 (1:1 매칭)
    Shared,         // 공유 목적지 (여러 캐릭터가 같은 목적지)
    Single          // 단일 목적지 (모든 캐릭터가 하나의 목적지로)
}using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;

#if UNITY_EDITOR
using UnityEditor;
#endif

/// <summary>
/// Unity Editor에서 레벨을 생성하고 관리하는 시스템
/// Tilemap을 읽어서 LevelData ScriptableObject로 변환합니다
/// </summary>
public class LevelGenerator : MonoBehaviour
{
    [Header("Tilemap References")]
    [SerializeField] private Tilemap tilemap;
    [SerializeField] private Grid grid;

    [Header("Generation Settings")]
    [SerializeField] private int levelNumber = 1;
    [SerializeField] private string levelName = "Level 1";
    [SerializeField] private float moveSpeed = 2f;
    [SerializeField] private bool showGridInGame = false;

    [Header("Character Setup")]
    [SerializeField] private List<CharacterSetup> characterSetups = new List<CharacterSetup>();

    [Header("Goal Setup")]
    [SerializeField] private List<GoalSetup> goalSetups = new List<GoalSetup>();

    [System.Serializable]
    public struct CharacterSetup
    {
        public string characterId;
        public Vector3Int startPosition;
        public int maxSelections;
        public Color characterColor;
        public int assignedGoalIndex; // -1 for shared goals

        public CharacterSetup(string id, Vector3Int startPos, int maxSel, Color color, int goalIndex = -1)
        {
            characterId = id;
            startPosition = startPos;
            maxSelections = maxSel;
            characterColor = color;
            assignedGoalIndex = goalIndex;
        }
    }

    [System.Serializable]
    public struct GoalSetup
    {
        public Vector3Int position;
        public GoalType goalType;
        public Color goalColor;

        public GoalSetup(Vector3Int pos, GoalType type, Color color)
        {
            position = pos;
            goalType = type;
            goalColor = color;
        }
    }

    void Start()
    {
        // 자동으로 Grid와 Tilemap 찾기
        if (grid == null)
            grid = FindFirstObjectByType<Grid>();

        if (tilemap == null)
        {
            var tilemaps = FindObjectsByType<Tilemap>(FindObjectsSortMode.None);
            if (tilemaps.Length > 0)
                tilemap = tilemaps[0];
        }
    }

#if UNITY_EDITOR
    [ContextMenu("Generate Level Data")]
    public void GenerateLevelData()
    {
        if (tilemap == null)
        {
            Debug.LogError("Tilemap이 설정되지 않았습니다!");
            return;
        }

        if (grid == null)
        {
            Debug.LogError("Grid가 설정되지 않았습니다!");
            return;
        }

        // LevelData 생성
        LevelData levelData = CreateLevelDataFromScene();

        // ScriptableObject로 저장
        SaveLevelData(levelData);

        Debug.Log($"레벨 데이터 생성 완료: {levelData.name}");
        levelData.LogLevelInfo();
    }

    private LevelData CreateLevelDataFromScene()
    {
        LevelData levelData = ScriptableObject.CreateInstance<LevelData>();

        // 기본 정보 설정
        levelData.levelNumber = levelNumber;
        levelData.levelName = levelName;
        levelData.moveSpeed = moveSpeed;
        levelData.showGridInGame = showGridInGame;

        // 그리드 설정 - Grid 컴포넌트에서 직접 가져오기
        levelData.cellSize = grid != null ? grid.cellSize.x : 1f;
        levelData.gridOrigin = transform.position;

        // Tilemap에서 타일 정보 읽어오기
        ReadTilemapData(levelData);

        // 캐릭터 설정 추가
        foreach (var setup in characterSetups)
        {
            levelData.AddCharacter(
                setup.characterId,
                setup.startPosition,
                setup.maxSelections,
                setup.characterColor,
                setup.assignedGoalIndex
            );
        }

        // 목적지 설정 추가
        foreach (var setup in goalSetups)
        {
            levelData.AddGoal(setup.position, setup.goalType, setup.goalColor);
        }

        // 그리드 크기 계산
        CalculateGridBounds(levelData);

        return levelData;
    }

    private void ReadTilemapData(LevelData levelData)
    {
        Debug.Log("=== Reading Tilemap Data ===");

        // 기존 타일 데이터 클리어
        levelData.walkableTiles.Clear();
        levelData.tileTypes.Clear();

        BoundsInt bounds = tilemap.cellBounds;
        TileBase[] tiles = tilemap.GetTilesBlock(bounds);

        // 타일 타입 매핑 생성
        Dictionary<TileBase, int> tileToTypeId = new Dictionary<TileBase, int>();
        int nextTypeId = 0;

        Debug.Log($"Scanning tilemap bounds: {bounds}");
        Debug.Log($"Total tile slots: {tiles.Length}");

        int processedTiles = 0;

        for (int x = 0; x < bounds.size.x; x++)
        {
            for (int y = 0; y < bounds.size.y; y++)
            {
                TileBase tile = tiles[x + y * bounds.size.x];
                if (tile != null)
                {
                    Vector3Int position = new Vector3Int(
                        bounds.x + x,
                        bounds.y + y,
                        0
                    );

                    // 새로운 타일 타입이면 등록
                    if (!tileToTypeId.ContainsKey(tile))
                    {
                        tileToTypeId[tile] = nextTypeId;

                        // 타일 에셋 경로 가져오기
                        string assetPath = "";
#if UNITY_EDITOR
                        assetPath = UnityEditor.AssetDatabase.GetAssetPath(tile);
#endif

                        levelData.AddTileType(
                            nextTypeId,
                            tile.name,
                            assetPath,
                            true  // 기본적으로 모든 타일은 이동 가능
                        );

                        Debug.Log($"New tile type registered: ID={nextTypeId}, Name={tile.name}, Path={assetPath}");
                        nextTypeId++;
                    }

                    // 타일 데이터 저장
                    levelData.AddTile(
                        position,
                        true,
                        tile.name,
                        tileToTypeId[tile]
                    );

                    processedTiles++;
                }
            }
        }

        Debug.Log($"=== Tilemap Reading Complete ===");
        Debug.Log($"Processed tiles: {processedTiles}");
        Debug.Log($"Unique tile types: {levelData.tileTypes.Count}");
        Debug.Log($"Total saved tiles: {levelData.walkableTiles.Count}");

        // 타일 타입 정보 출력
        foreach (var tileType in levelData.tileTypes)
        {
            int count = levelData.walkableTiles.FindAll(t => t.tileTypeId == tileType.typeId).Count;
            Debug.Log($"  - {tileType.typeName} (ID: {tileType.typeId}): {count} tiles");
        }
    }

    private void CalculateGridBounds(LevelData levelData)
    {
        if (levelData.walkableTiles.Count == 0)
        {
            levelData.gridWidth = 10;
            levelData.gridHeight = 10;
            return;
        }

        int minX = int.MaxValue, maxX = int.MinValue;
        int minY = int.MaxValue, maxY = int.MinValue;

        foreach (var tile in levelData.walkableTiles)
        {
            if (tile.position.x < minX) minX = tile.position.x;
            if (tile.position.x > maxX) maxX = tile.position.x;
            if (tile.position.y < minY) minY = tile.position.y;
            if (tile.position.y > maxY) maxY = tile.position.y;
        }

        levelData.gridWidth = maxX - minX + 1;
        levelData.gridHeight = maxY - minY + 1;
        levelData.gridOrigin = new Vector3(minX, minY, 0);
    }

    private void SaveLevelData(LevelData levelData)
    {
        string path = $"Assets/ScriptableObjects/LevelData/Level_{levelNumber:D2}.asset";

        // 폴더가 없으면 생성
        string directory = System.IO.Path.GetDirectoryName(path);
        if (!System.IO.Directory.Exists(directory))
        {
            System.IO.Directory.CreateDirectory(directory);
        }

        // ScriptableObject 저장
        AssetDatabase.CreateAsset(levelData, path);
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();

        // Inspector에서 선택
        Selection.activeObject = levelData;

        Debug.Log($"LevelData saved to: {path}");
    }

    [ContextMenu("Add Sample Character")]
    public void AddSampleCharacter()
    {
        Color[] colors = { Color.red, Color.blue, Color.green, Color.yellow };
        string[] ids = { "A", "B", "C", "D" };

        int index = characterSetups.Count;
        if (index < 4)
        {
            characterSetups.Add(new CharacterSetup(
                ids[index],
                new Vector3Int(index, 0, 0),
                3,
                colors[index],
                -1
            ));
        }
    }

    [ContextMenu("Add Sample Goal")]
    public void AddSampleGoal()
    {
        goalSetups.Add(new GoalSetup(
            new Vector3Int(5, 5, 0),
            GoalType.Individual,
            Color.white
        ));
    }

    [ContextMenu("Clear Setup Data")]
    public void ClearSetupData()
    {
        characterSetups.Clear();
        goalSetups.Clear();
    }

    [ContextMenu("Validate Current Setup")]
    public void ValidateSetup()
    {
        if (characterSetups.Count < 2)
        {
            Debug.LogWarning("캐릭터가 2개 미만입니다.");
        }

        if (goalSetups.Count == 0)
        {
            Debug.LogWarning("목적지가 설정되지 않았습니다.");
        }

        // 위치 중복 체크
        HashSet<Vector3Int> positions = new HashSet<Vector3Int>();

        foreach (var character in characterSetups)
        {
            if (positions.Contains(character.startPosition))
            {
                Debug.LogWarning($"캐릭터 위치 중복: {character.startPosition}");
            }
            positions.Add(character.startPosition);
        }

        foreach (var goal in goalSetups)
        {
            if (positions.Contains(goal.position))
            {
                Debug.LogWarning($"목적지가 캐릭터와 같은 위치에 있습니다: {goal.position}");
            }
        }

        Debug.Log("설정 검증 완료!");
    }
#endif

    /// <summary>
    /// 런타임에서 LevelData를 로드하여 레벨을 설정
    /// </summary>
    public void LoadLevelData(LevelData levelData)
    {
        if (levelData == null)
        {
            Debug.LogError("LevelData가 null입니다!");
            return;
        }

        // Grid 설정 적용
        if (grid != null)
        {
            grid.cellSize = new Vector3(levelData.cellSize, levelData.cellSize, 1f);
            transform.position = levelData.gridOrigin;
        }

        Debug.Log($"Level {levelData.levelNumber} 로드 완료: {levelData.levelName}");
    }
}using UnityEngine;

#if UNITY_EDITOR
using UnityEditor;
#endif

/// <summary>
/// Grid 좌표를 시각적으로 표시하는 시스템
/// Unity Editor에서만 작동하며, 격자와 좌표를 Scene 뷰에 그려줍니다
/// </summary>
public class GridVisualizer : MonoBehaviour
{
    [Header("Grid Settings")]
    [SerializeField] private int gridWidth = 10;
    [SerializeField] private int gridHeight = 10;
    [SerializeField] private float cellSize = 1f;
    [SerializeField] private Vector3 gridOrigin = Vector3.zero;

    [Header("Visual Settings")]
    [SerializeField] private Color gridLineColor = Color.white;
    [SerializeField] private Color coordinateTextColor = Color.yellow;
    [SerializeField] private bool showCoordinates = true;
    [SerializeField] private bool showGrid = true;
    [SerializeField] private float lineAlpha = 0.5f;

    [Header("Coordinate Settings")]
    [SerializeField] private bool showOnlyIntersections = true;
    [SerializeField] private float textSize = 0.15f;
    [SerializeField] private bool syncWithCamera = true;

    void Start()
    {
        if (syncWithCamera)
        {
            SyncCameraToGrid();
        }
    }

    /// <summary>
    /// 카메라를 Grid에 맞춰 자동 조정
    /// </summary>
    public void SyncCameraToGrid()
    {
        Camera mainCamera = Camera.main;
        if (mainCamera == null) return;

        // 그리드 중앙 위치 계산
        Vector3 gridCenter = new Vector3(
            gridOrigin.x + (gridWidth * cellSize) / 2f - cellSize / 2f,
            gridOrigin.y + (gridHeight * cellSize) / 2f - cellSize / 2f,
            mainCamera.transform.position.z
        );

        // 카메라 위치를 그리드 중앙으로
        mainCamera.transform.position = gridCenter;

        // 카메라 크기를 그리드에 맞춰 조정 (여백 포함)
        float gridAspect = (float)gridWidth / gridHeight;
        float cameraAspect = mainCamera.aspect;

        if (gridAspect > cameraAspect)
        {
            // 그리드가 더 넓음 - 가로 기준으로 맞춤
            mainCamera.orthographicSize = (gridWidth * cellSize) / (2f * cameraAspect) + 1f;
        }
        else
        {
            // 그리드가 더 높음 - 세로 기준으로 맞춤  
            mainCamera.orthographicSize = (gridHeight * cellSize) / 2f + 1f;
        }

        Debug.Log($"Camera synced to Grid - Position: {gridCenter}, Size: {mainCamera.orthographicSize}");
    }
    public Vector3Int WorldToGridPosition(Vector3 worldPosition)
    {
        Vector3 localPos = worldPosition - gridOrigin;
        return new Vector3Int(
            Mathf.FloorToInt(localPos.x / cellSize),  // RoundToInt → FloorToInt
            Mathf.FloorToInt(localPos.y / cellSize),  // RoundToInt → FloorToInt
            0
        );
    }

    /// <summary>
    /// 그리드 좌표를 월드 좌표로 변환
    /// </summary>
    public Vector3 GridToWorldPosition(Vector3Int gridPosition)
    {
        return new Vector3(
    gridPosition.x * cellSize + cellSize * 0.5f,
    gridPosition.y * cellSize + cellSize * 0.5f,
    0
) + gridOrigin;
    }

    /// <summary>
    /// 특정 그리드 좌표가 유효한 범위 내에 있는지 확인
    /// </summary>
    public bool IsValidGridPosition(Vector3Int gridPosition)
    {
        return gridPosition.x >= 0 && gridPosition.x < gridWidth &&
               gridPosition.y >= 0 && gridPosition.y < gridHeight;
    }

    /// <summary>
    /// 그리드 범위 내의 모든 유효한 좌표를 반환
    /// </summary>
    public Vector3Int[] GetAllGridPositions()
    {
        var positions = new Vector3Int[gridWidth * gridHeight];
        int index = 0;

        for (int x = 0; x < gridWidth; x++)
        {
            for (int y = 0; y < gridHeight; y++)
            {
                positions[index] = new Vector3Int(x, y, 0);
                index++;
            }
        }

        return positions;
    }

    [ContextMenu("Sync to Scene Grid")]
    public void SyncToSceneGrid()
    {
        Grid sceneGrid = FindFirstObjectByType<Grid>();
        if (sceneGrid != null)
        {
            cellSize = sceneGrid.cellSize.x;
            gridOrigin = sceneGrid.transform.position;
            Debug.Log($"Synced to Scene Grid - Cell Size: {cellSize}, Origin: {gridOrigin}");
        }
    }
#if UNITY_EDITOR
    void OnDrawGizmos()
    {
        if (!showGrid && !showCoordinates) return;

        // 그리드 라인 색상 설정
        Color originalColor = Gizmos.color;
        Color lineColor = gridLineColor;
        lineColor.a = lineAlpha;
        Gizmos.color = lineColor;

        if (showGrid)
        {
            DrawGridLines();
        }

        if (showCoordinates)
        {
            DrawCoordinates();
        }

        Gizmos.color = originalColor;
    }

    private void DrawGridLines()
    {
        // 세로선 그리기
        for (int x = 0; x <= gridWidth; x++)
        {
            Vector3 start = new Vector3(x * cellSize, 0, 0) + gridOrigin;
            Vector3 end = new Vector3(x * cellSize, gridHeight * cellSize, 0) + gridOrigin;
            Gizmos.DrawLine(start, end);
        }

        // 가로선 그리기
        for (int y = 0; y <= gridHeight; y++)
        {
            Vector3 start = new Vector3(0, y * cellSize, 0) + gridOrigin;
            Vector3 end = new Vector3(gridWidth * cellSize, y * cellSize, 0) + gridOrigin;
            Gizmos.DrawLine(start, end);
        }
    }

    private void DrawCoordinates()
    {
        GUIStyle style = new GUIStyle();
        style.normal.textColor = coordinateTextColor;
        style.fontSize = Mathf.RoundToInt(textSize * 100); // 크기 조정
        style.alignment = TextAnchor.MiddleCenter;
        style.fontStyle = FontStyle.Bold; // 가독성을 위해 볼드체

        for (int x = 0; x < gridWidth; x++)
        {
            for (int y = 0; y < gridHeight; y++)
            {
                if (showOnlyIntersections)
                {
                    Vector3 worldPos = GridToWorldPosition(new Vector3Int(x, y, 0));

                    // Scene 뷰에서만 보이도록
                    if (SceneView.currentDrawingSceneView != null)
                    {
                        // 텍스트 크기에 맞춰 위치 조정
                        Vector3 textPos = worldPos;
                        Handles.Label(textPos, $"{x},{y}", style);
                    }
                }
            }
        }
    }

    // 에디터에서 값 변경 시 씬 뷰 업데이트
    void OnValidate()
    {
        if (gridWidth < 1) gridWidth = 1;
        if (gridHeight < 1) gridHeight = 1;
        if (cellSize <= 0) cellSize = 1f;
        if (textSize <= 0) textSize = 0.1f;
        if (lineAlpha < 0) lineAlpha = 0f;
        if (lineAlpha > 1) lineAlpha = 1f;

        // 값 변경 시 카메라 재동기화
        if (syncWithCamera && Application.isPlaying)
        {
            SyncCameraToGrid();
        }
    }

#if UNITY_EDITOR
    [ContextMenu("Sync Camera to Grid")]
    public void SyncCameraToGridEditor()
    {
        SyncCameraToGrid();
    }

    [ContextMenu("Set Grid Size to Level Data")]
    public void SetGridSizeToLevelData()
    {
        // 현재 선택된 LevelData에서 크기 가져오기
        if (Selection.activeObject is LevelData levelData)
        {
            gridWidth = levelData.gridWidth;
            gridHeight = levelData.gridHeight;
            cellSize = levelData.cellSize;
            gridOrigin = levelData.gridOrigin;

            if (syncWithCamera)
            {
                SyncCameraToGrid();
            }

            Debug.Log($"Grid size set from LevelData: {gridWidth}x{gridHeight}");
        }
        else
        {
            Debug.LogWarning("Please select a LevelData asset first!");
        }
    }
#endif
#endif

    // 런타임에서 디버그 정보 확인용
    [System.Diagnostics.Conditional("UNITY_EDITOR")]
    public void LogGridInfo()
    {
        Debug.Log($"Grid Info - Width: {gridWidth}, Height: {gridHeight}, Cell Size: {cellSize}");
        Debug.Log($"Grid Origin: {gridOrigin}");
        Debug.Log($"Total Grid Cells: {gridWidth * gridHeight}");
    }

    /// <summary>
    /// 에디터 전용: 특정 위치에 기즈모 그리기
    /// </summary>
    public void DrawPositionGizmo(Vector3Int gridPos, Color color)
    {
#if UNITY_EDITOR
        Vector3 worldPos = GridToWorldPosition(gridPos);
        Gizmos.color = color;
        Gizmos.DrawWireCube(worldPos, Vector3.one * cellSize * 0.8f);
#endif
    }
}using UnityEngine;
using UnityEngine.UI;

public class SafeArea : MonoBehaviour
{
    private RectTransform rectTransform;
    private Rect safeArea;
    private Vector2 minAnchor;
    private Vector2 maxAnchor;

    void Start()
    {
        rectTransform = GetComponent<RectTransform>();
        safeArea = Screen.safeArea;

        // 안전 영역을 정규화된 좌표로 변환
        minAnchor = safeArea.position;
        maxAnchor = minAnchor + safeArea.size;

        minAnchor.x /= Screen.width;
        minAnchor.y /= Screen.height;
        maxAnchor.x /= Screen.width;
        maxAnchor.y /= Screen.height;

        // RectTransform에 적용
        rectTransform.anchorMin = minAnchor;
        rectTransform.anchorMax = maxAnchor;
    }

    void Update()
    {
        // 실시간으로 안전영역 변경 감지 (기기 회전 등)
        if (safeArea != Screen.safeArea)
        {
            Start(); // 다시 계산
        }
    }
}//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated by com.unity.inputsystem:InputActionCodeGenerator
//     version 1.14.1
//     from Assets/PlayerInputActions.inputactions
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Utilities;

/// <summary>
/// Provides programmatic access to <see cref="InputActionAsset" />, <see cref="InputActionMap" />, <see cref="InputAction" /> and <see cref="InputControlScheme" /> instances defined in asset "Assets/PlayerInputActions.inputactions".
/// </summary>
/// <remarks>
/// This class is source generated and any manual edits will be discarded if the associated asset is reimported or modified.
/// </remarks>
/// <example>
/// <code>
/// using namespace UnityEngine;
/// using UnityEngine.InputSystem;
///
/// // Example of using an InputActionMap named "Player" from a UnityEngine.MonoBehaviour implementing callback interface.
/// public class Example : MonoBehaviour, MyActions.IPlayerActions
/// {
///     private MyActions_Actions m_Actions;                  // Source code representation of asset.
///     private MyActions_Actions.PlayerActions m_Player;     // Source code representation of action map.
///
///     void Awake()
///     {
///         m_Actions = new MyActions_Actions();              // Create asset object.
///         m_Player = m_Actions.Player;                      // Extract action map object.
///         m_Player.AddCallbacks(this);                      // Register callback interface IPlayerActions.
///     }
///
///     void OnDestroy()
///     {
///         m_Actions.Dispose();                              // Destroy asset object.
///     }
///
///     void OnEnable()
///     {
///         m_Player.Enable();                                // Enable all actions within map.
///     }
///
///     void OnDisable()
///     {
///         m_Player.Disable();                               // Disable all actions within map.
///     }
///
///     #region Interface implementation of MyActions.IPlayerActions
///
///     // Invoked when "Move" action is either started, performed or canceled.
///     public void OnMove(InputAction.CallbackContext context)
///     {
///         Debug.Log($"OnMove: {context.ReadValue&lt;Vector2&gt;()}");
///     }
///
///     // Invoked when "Attack" action is either started, performed or canceled.
///     public void OnAttack(InputAction.CallbackContext context)
///     {
///         Debug.Log($"OnAttack: {context.ReadValue&lt;float&gt;()}");
///     }
///
///     #endregion
/// }
/// </code>
/// </example>
public partial class @PlayerInputActions: IInputActionCollection2, IDisposable
{
    /// <summary>
    /// Provides access to the underlying asset instance.
    /// </summary>
    public InputActionAsset asset { get; }

    /// <summary>
    /// Constructs a new instance.
    /// </summary>
    public @PlayerInputActions()
    {
        asset = InputActionAsset.FromJson(@"{
    ""version"": 1,
    ""name"": ""PlayerInputActions"",
    ""maps"": [
        {
            ""name"": ""Player"",
            ""id"": ""aeb9e1e7-1282-4826-ad2b-52706077229d"",
            ""actions"": [
                {
                    ""name"": ""Touch"",
                    ""type"": ""Value"",
                    ""id"": ""37b1c881-7b89-4e10-8d0e-73fc92fb3468"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": true
                },
                {
                    ""name"": ""TouchPress"",
                    ""type"": ""Button"",
                    ""id"": ""2c11d4d5-2d5e-42e6-bde0-18c9b1c03378"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""406e52a9-7606-4cb2-a130-e9d50734ee65"",
                    ""path"": ""<Touchscreen>/primaryTouch/position"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Touch"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""38474d63-ed1c-446b-b010-2fd94de90658"",
                    ""path"": ""<Mouse>/position"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Touch"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""1601d3f3-f96a-4c67-9307-6f9234846caa"",
                    ""path"": """",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Touch"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""6d509a41-9ae7-4e6b-bd66-883a6c4ceaff"",
                    ""path"": ""<Mouse>/leftButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""TouchPress"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""c208abbd-347e-4a66-82c0-d8c8824472b5"",
                    ""path"": ""<Touchscreen>/primaryTouch/pressure"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""TouchPress"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        }
    ],
    ""controlSchemes"": []
}");
        // Player
        m_Player = asset.FindActionMap("Player", throwIfNotFound: true);
        m_Player_Touch = m_Player.FindAction("Touch", throwIfNotFound: true);
        m_Player_TouchPress = m_Player.FindAction("TouchPress", throwIfNotFound: true);
    }

    ~@PlayerInputActions()
    {
        UnityEngine.Debug.Assert(!m_Player.enabled, "This will cause a leak and performance issues, PlayerInputActions.Player.Disable() has not been called.");
    }

    /// <summary>
    /// Destroys this asset and all associated <see cref="InputAction"/> instances.
    /// </summary>
    public void Dispose()
    {
        UnityEngine.Object.Destroy(asset);
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.bindingMask" />
    public InputBinding? bindingMask
    {
        get => asset.bindingMask;
        set => asset.bindingMask = value;
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.devices" />
    public ReadOnlyArray<InputDevice>? devices
    {
        get => asset.devices;
        set => asset.devices = value;
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.controlSchemes" />
    public ReadOnlyArray<InputControlScheme> controlSchemes => asset.controlSchemes;

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.Contains(InputAction)" />
    public bool Contains(InputAction action)
    {
        return asset.Contains(action);
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.GetEnumerator()" />
    public IEnumerator<InputAction> GetEnumerator()
    {
        return asset.GetEnumerator();
    }

    /// <inheritdoc cref="IEnumerable.GetEnumerator()" />
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.Enable()" />
    public void Enable()
    {
        asset.Enable();
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.Disable()" />
    public void Disable()
    {
        asset.Disable();
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.bindings" />
    public IEnumerable<InputBinding> bindings => asset.bindings;

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.FindAction(string, bool)" />
    public InputAction FindAction(string actionNameOrId, bool throwIfNotFound = false)
    {
        return asset.FindAction(actionNameOrId, throwIfNotFound);
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.FindBinding(InputBinding, out InputAction)" />
    public int FindBinding(InputBinding bindingMask, out InputAction action)
    {
        return asset.FindBinding(bindingMask, out action);
    }

    // Player
    private readonly InputActionMap m_Player;
    private List<IPlayerActions> m_PlayerActionsCallbackInterfaces = new List<IPlayerActions>();
    private readonly InputAction m_Player_Touch;
    private readonly InputAction m_Player_TouchPress;
    /// <summary>
    /// Provides access to input actions defined in input action map "Player".
    /// </summary>
    public struct PlayerActions
    {
        private @PlayerInputActions m_Wrapper;

        /// <summary>
        /// Construct a new instance of the input action map wrapper class.
        /// </summary>
        public PlayerActions(@PlayerInputActions wrapper) { m_Wrapper = wrapper; }
        /// <summary>
        /// Provides access to the underlying input action "Player/Touch".
        /// </summary>
        public InputAction @Touch => m_Wrapper.m_Player_Touch;
        /// <summary>
        /// Provides access to the underlying input action "Player/TouchPress".
        /// </summary>
        public InputAction @TouchPress => m_Wrapper.m_Player_TouchPress;
        /// <summary>
        /// Provides access to the underlying input action map instance.
        /// </summary>
        public InputActionMap Get() { return m_Wrapper.m_Player; }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.Enable()" />
        public void Enable() { Get().Enable(); }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.Disable()" />
        public void Disable() { Get().Disable(); }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.enabled" />
        public bool enabled => Get().enabled;
        /// <summary>
        /// Implicitly converts an <see ref="PlayerActions" /> to an <see ref="InputActionMap" /> instance.
        /// </summary>
        public static implicit operator InputActionMap(PlayerActions set) { return set.Get(); }
        /// <summary>
        /// Adds <see cref="InputAction.started"/>, <see cref="InputAction.performed"/> and <see cref="InputAction.canceled"/> callbacks provided via <param cref="instance" /> on all input actions contained in this map.
        /// </summary>
        /// <param name="instance">Callback instance.</param>
        /// <remarks>
        /// If <paramref name="instance" /> is <c>null</c> or <paramref name="instance"/> have already been added this method does nothing.
        /// </remarks>
        /// <seealso cref="PlayerActions" />
        public void AddCallbacks(IPlayerActions instance)
        {
            if (instance == null || m_Wrapper.m_PlayerActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_PlayerActionsCallbackInterfaces.Add(instance);
            @Touch.started += instance.OnTouch;
            @Touch.performed += instance.OnTouch;
            @Touch.canceled += instance.OnTouch;
            @TouchPress.started += instance.OnTouchPress;
            @TouchPress.performed += instance.OnTouchPress;
            @TouchPress.canceled += instance.OnTouchPress;
        }

        /// <summary>
        /// Removes <see cref="InputAction.started"/>, <see cref="InputAction.performed"/> and <see cref="InputAction.canceled"/> callbacks provided via <param cref="instance" /> on all input actions contained in this map.
        /// </summary>
        /// <remarks>
        /// Calling this method when <paramref name="instance" /> have not previously been registered has no side-effects.
        /// </remarks>
        /// <seealso cref="PlayerActions" />
        private void UnregisterCallbacks(IPlayerActions instance)
        {
            @Touch.started -= instance.OnTouch;
            @Touch.performed -= instance.OnTouch;
            @Touch.canceled -= instance.OnTouch;
            @TouchPress.started -= instance.OnTouchPress;
            @TouchPress.performed -= instance.OnTouchPress;
            @TouchPress.canceled -= instance.OnTouchPress;
        }

        /// <summary>
        /// Unregisters <param cref="instance" /> and unregisters all input action callbacks via <see cref="PlayerActions.UnregisterCallbacks(IPlayerActions)" />.
        /// </summary>
        /// <seealso cref="PlayerActions.UnregisterCallbacks(IPlayerActions)" />
        public void RemoveCallbacks(IPlayerActions instance)
        {
            if (m_Wrapper.m_PlayerActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        /// <summary>
        /// Replaces all existing callback instances and previously registered input action callbacks associated with them with callbacks provided via <param cref="instance" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="instance" /> is <c>null</c>, calling this method will only unregister all existing callbacks but not register any new callbacks.
        /// </remarks>
        /// <seealso cref="PlayerActions.AddCallbacks(IPlayerActions)" />
        /// <seealso cref="PlayerActions.RemoveCallbacks(IPlayerActions)" />
        /// <seealso cref="PlayerActions.UnregisterCallbacks(IPlayerActions)" />
        public void SetCallbacks(IPlayerActions instance)
        {
            foreach (var item in m_Wrapper.m_PlayerActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_PlayerActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    /// <summary>
    /// Provides a new <see cref="PlayerActions" /> instance referencing this action map.
    /// </summary>
    public PlayerActions @Player => new PlayerActions(this);
    /// <summary>
    /// Interface to implement callback methods for all input action callbacks associated with input actions defined by "Player" which allows adding and removing callbacks.
    /// </summary>
    /// <seealso cref="PlayerActions.AddCallbacks(IPlayerActions)" />
    /// <seealso cref="PlayerActions.RemoveCallbacks(IPlayerActions)" />
    public interface IPlayerActions
    {
        /// <summary>
        /// Method invoked when associated input action "Touch" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnTouch(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "TouchPress" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnTouchPress(InputAction.CallbackContext context);
    }
}
